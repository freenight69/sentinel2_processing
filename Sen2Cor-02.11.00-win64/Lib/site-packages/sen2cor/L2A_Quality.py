import os, sys
from lxml import etree, objectify
from time import strftime
from datetime import datetime
import numpy as np
from L2A_XmlParser import L2A_XmlParser


class L2A_Quality(object):
    def __init__(self, config, tables):
        self._config = config
        self._tables = tables

        if self._config.get_operation_mode() == 'TOOLBOX':
            self._mission_id = '{}'.format((config.L1C_UP_ID)[0:3])
        else:
            self._mission_id = '{}'.format((config.L2A_DS_ID)[0:3])
        # this needs to be retrieved via the config module:
        self._aot_retieval_accuracy = config.aot_retieval_accuracy
        if config.scOnly == False:
            self._aot_retrieval_method = config.aot_retrieval_method
        else:
            self._aot_retrieval_method = 'DEFAULT'
        self._blue_path_radiance_rescaling_factor = config.get_sc_lp_blu()
        self._ddv_pixel_percentage = config.ddv_pixel_percentage
        self._ddv_reflectance_range = config.ddv_reflectance_range
        self._final_visibility = config.final_visibility
        self._ground_elevation_above_3 = config.ground_elevation_above_3
        self._ozone_setpoint = config.ozoneSetpoint
        self._ozone_source = config.ozoneSource
        self._radiative_transfer_accuracy = config.radiative_transfer_accuracy
        self._start_visibility = config.visibility
        self._visibility_from_ddv = config.visibility_from_ddv
        self._water_vapour_retrieval_accuracy = config.water_vapour_retrieval_accuracy
        self._water_vapour_retrieval_method = config.water_vapour_retrieval_method

        # to retrieve the degraded MSI data percentage:
        xp = L2A_XmlParser(self._config, 'T2A')
        qualityIndicatorsInfo = 'Quality_Indicators_Info'
        imageContentQI = 'Image_Content_QI'
        icqi = xp.getTree(qualityIndicatorsInfo, imageContentQI)
        self._nr_px_degraded_msi_data = icqi.DEGRADED_MSI_DATA_PERCENTAGE.pyval
        xp = None

        # to retrieve the scene classification parameters:
        try:
            self._nr_px_full_tile = (config.default_nrows * config.default_ncols) #using  config variables from metadata T2A
        except:
            if self._config.resolution == 20:
                self._nr_px_full_tile = (5490 * 5490)
            else:
                self._nr_px_full_tile = (1830 * 1830)

        sc = tables.getBand(tables.SCL)
        self._nr_px_total_scl = sc.size
        self._nr_px_no_data_scl = sc[sc==config.noData].size
        self._nr_px_saturated_defective = sc[sc==config.saturatedDefective].size

        self._nr_px_total_nodata_pixel = (self._nr_px_full_tile - self._nr_px_total_scl) + self._nr_px_no_data_scl

        self._nr_px_valid = self._nr_px_full_tile - self._nr_px_total_nodata_pixel - self._nr_px_saturated_defective

        self._nr_px_dark_features = sc[sc==config.darkFeatures].size
        self._nr_px_cloud_shadows = sc[sc==config.cloudShadows].size
        self._nr_px_vegetated = sc[sc==config.vegetation].size
        self._nr_px_not_vegetated = sc[sc==config.bareSoils].size
        self._nr_px_water = sc[sc==config.water].size
        self._nr_px_unclassified = sc[sc==config.lowProbaClouds].size
        self._nr_px_med_proba_clouds = sc[sc==config.medProbaClouds].size
        self._nr_px_hi_proba_clouds = sc[sc==config.highProbaClouds].size
        self._nr_px_thin_cirrus = sc[sc==config.thinCirrus].size
        self._nr_px_snow_ice = sc[sc==config.snowIce].size
        self._nr_px_clouds_over_land = config.nr_px_clouds_over_land
        self._nr_cloud_coverage = self._nr_px_med_proba_clouds + self._nr_px_hi_proba_clouds + self._nr_px_thin_cirrus
        self._all_clouds = 12
        self._clouds_over_land = 13
        self._negative_boa_pixels = 14
        self._degraded_msi_data = 15
        sc = None

        #these parameters can be retrieved via the tables module:
        if config.scOnly == False:
            aot = tables.getBand(tables.AOT)
            self._granule_mean_aot = np.float32(aot[aot>0].mean() * 0.001)
            if self._granule_mean_aot > 1.0:
                self._aot_above_1 = 'True'
            else:
                self._aot_above_1 = 'False'
            aot = None
        else:
            self._granule_mean_aot = -999
            self._aot_above_1= 'NA'

        if config.scOnly == False:
            if config.track_iwaterwv > 0:
                wvp = tables.getBand(tables.WVP)
                all_zero= not wvp.any()
                if not all_zero:
                    self._granule_mean_wv = np.float32(wvp[wvp>0].mean() * 0.001)
                else:
                    self._granule_mean_wv = 0.0
                if self._granule_mean_wv > 5.0:
                    self._wv_above_5 = 'True'
                else:
                    self._wv_above_5 = 'False'
                wvp = None
            else:
                self._granule_mean_wv = -999
                self._wv_above_5 = 'NA'
        else:
            self._granule_mean_wv = -999
            self._wv_above_5 = 'NA'

        if config.scOnly == False:
            if self._final_visibility <= 5.0:
                self._vis_less_5 = 'True'
            else:
                self._vis_less_5 = 'False'
        else:
            self._granule_mean_vis = -999
            self._vis_less_5  = 'NA'

        self._solar_zenith_angle = config.get_solze()
        if self._solar_zenith_angle > 70.0:
            self._sza_above_70 = 'True'
        else:
            self._sza_above_70 = 'False'

        if config.demType == 'SRTM':
            self._dem_type = 'SRTM_90'
        elif config.demType == 'DTED':
            self._dem_type = 'DTED_90'
        elif config.demType == 'DTED_30':
            self._dem_type = 'DTED_30'
        elif config.demType == 'COPERNICUS_90':
            self._dem_type = 'COPERNICUS_90'
        elif config.demType == 'COPERNICUS_30':
            self._dem_type = 'COPERNICUS_30'
        else:
            self._dem_type = 'NA'

        if self._dem_type == 'NA':
            self._dem_mean_alt = np.float64(self._config.altit*1000.) #'NA'
            self._dem_mean_slope = np.float64(0.0) #'NA'
            self._average_dem_profile = 'FLAT'
            self._average_dem_slope = 'FLAT'
        else:
            dem = tables.getBand(tables.DEM)
            all_zero_dem = not dem.any()
            if not all_zero_dem:
                self._dem_mean_alt = dem[dem > 0].mean()
            else:
                self._dem_mean_alt = np.float64(self._config.altit * 1000.)
            if self._dem_mean_alt < 100:
                self._average_dem_profile = 'FLAT'
            elif self._dem_mean_alt < 610:
                self._average_dem_profile = 'MIDDLE'
            else:
                self._average_dem_profile = 'MOUNTAINOUS'
            dem = None

            slp = tables.getBand(tables.SLP)
            self._dem_mean_slope = slp[slp > 0].mean()
            if self._dem_mean_slope < 1.0:
                self._average_dem_slope = 'FLAT'
            elif self._dem_mean_slope < 5.0:
                self._average_dem_slope = 'GENTLE'
            else:
                self._average_dem_slope = 'STEEP'
            slp = None

    def update_qi(self):
        switch_case = {
            'CLOUDY_PIXEL_PERCENTAGE': format('%f' % self.get_percentage \
                (self._all_clouds, self._nr_cloud_coverage)),
            'NODATA_PIXEL_PERCENTAGE': format('%f' % self.get_percentage\
                (self._config.noData, self._nr_px_total_nodata_pixel)),
            'SATURATED_DEFECTIVE_PIXEL_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.saturatedDefective, self._nr_px_saturated_defective)),
            'DARK_FEATURES_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.darkFeatures, self._nr_px_dark_features)),
            'CLOUD_SHADOW_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.cloudShadows, self._nr_px_cloud_shadows)),
            'VEGETATION_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.vegetation, self._nr_px_vegetated)),
            'NOT_VEGETATED_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.bareSoils, self._nr_px_not_vegetated)),
            'WATER_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.water, self._nr_px_water)),
            'UNCLASSIFIED_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.lowProbaClouds, self._nr_px_unclassified)),
            'MEDIUM_PROBA_CLOUDS_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.medProbaClouds, self._nr_px_med_proba_clouds)),
            'HIGH_PROBA_CLOUDS_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.highProbaClouds, self._nr_px_hi_proba_clouds)),
            'THIN_CIRRUS_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.thinCirrus, self._nr_px_thin_cirrus)),
            'SNOW_ICE_PERCENTAGE' : format('%f' % self.get_percentage\
                (self._config.snowIce, self._nr_px_snow_ice)),
            'CLOUDY_PIXEL_OVER_LAND_PERCENTAGE': format('%f' % self.get_cloud_over_land_percentage()),
            'DEGRADED_MSI_DATA_PERCENTAGE': format('%f' % self._nr_px_degraded_msi_data),
            'RADIATIVE_TRANSFER_ACCURACY': format('%f' % self._radiative_transfer_accuracy),
            'WV_RETRIEVAL_ACCURACY': format('%f' % self._water_vapour_retrieval_accuracy),
            'AOT_RETRIEVAL_ACCURACY': format('%f' % self._aot_retieval_accuracy),
            'AOT_RETRIEVAL_METHOD': format('%s' % self._aot_retrieval_method),
            'GRANULE_MEAN_AOT': format('%f' % self._granule_mean_aot),
            'GRANULE_MEAN_WV': format('%f' % self._granule_mean_wv),
            'OZONE_SOURCE': format('%s' % self._ozone_source),
            'OZONE_VALUE': format('%f' % self._ozone_setpoint)
        }
        if not self.update_qi_report(switch_case, 'SCENE_CLASS_QUALITY'):
            return False
        if not self.update_qi_metadata(switch_case, 'T2A'):
            return False
        if self._config.operationMode == 'TOOLBOX':
            if not self.update_qi_metadata(switch_case, 'UP2A'):
                return False

        switch_case = {
            'AOT_RETRIEVAL_ACCURACY': format('%f' % self._aot_retieval_accuracy),
            'GRANULE_MEAN_AOT': format('%f' % self._granule_mean_aot),
            'WV_RETRIEVAL_ACCURACY': format('%f' % self._water_vapour_retrieval_accuracy),
            'GRANULE_MEAN_WV': format('%f' % self._granule_mean_wv),
            'OZONE_VALUE': format('%f' % self._ozone_setpoint),
            'START_VISIBILITY_KM': format('%f' % self._start_visibility),
            'VISIBILITY_FROM_DDV_KM': format('%f' % self._visibility_from_ddv),
            'FINAL_VISIBILITY_KM': format('%f' % self._final_visibility),
            'AVERAGE_SOLAR_ZENITH_ANGLE': format('%f' % self._solar_zenith_angle),
            'DDV_PIXEL_PERCENTAGE': format('%f' % self._ddv_pixel_percentage),
            'DDV_REFLECTANCE_RANGE': format('%f' % self._ddv_reflectance_range),
            'BLUE_PATH_RADIANCE_RESCALING_FACTOR': format('%f' % self._blue_path_radiance_rescaling_factor),
            'WV_RETRIEVAL_METHOD': format('%s' % self._water_vapour_retrieval_method),
            'AOT_RETRIEVAL_METHOD': format('%s' % self._aot_retrieval_method),
            'VISIBILITY_LESS_THAN_5_KM': format('%s' % self._vis_less_5),
            'AOT_ABOVE_1': format('%s' % self._aot_above_1),
            'GRANULE_WV_ABOVE_5_CM': format('%s' % self._wv_above_5),
            'B01': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[0])),
            'B02': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[1])),
            'B03': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[2])),
            'B04': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[3])),
            'B05': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[4])),
            'B06': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[5])),
            'B07': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[6])),
            'B08': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[7])),
            'B8A': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[8])),
            'B11': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[11])),
            'B12': format('%f' % self.get_percentage(self._negative_boa_pixels, self._config.L2A_BOA_NEGATIVE_VALUES_LIST[12])),
            "LUT_DATA_FILES": self._config.lut_data_filelist
        }
        if not self.update_qi_report(switch_case, 'ATMOSPHERIC_CORRECTION_QUALITY'):
            return False

        switch_case = {
            "DEM_TYPE": self._dem_type,
            "DEM_MEAN_ALTITUDE_KM": str((self._dem_mean_alt/1000.).astype(np.float32)),
            "DEM_MEAN_SLOPE": str(self._dem_mean_slope),
            'GROUND_ELEVATION_ABOVE_3_KM': self._ground_elevation_above_3,
#            "AVERAGE_DEM_PROFILE": self._average_dem_profile,
#            "AVERAGE_DEM_SLOPE": self._average_dem_slope,
            'SOLAR_ZENITH_ANGLE_ABOVE_70_DEG': self._sza_above_70,
            'OZONE_SOURCE': self._ozone_source,
            "AUX_DATA_FILES": self._config.aux_data_filelist
        }
        if not self.update_qi_report(switch_case, 'AUX_DATA_QUALITY'):
            return False
        return True

    def get_percentage(self, classificator, value):
        nr_px_classified = value
        if classificator == self._config.noData:
            nr_px_total = self._nr_px_full_tile
        elif classificator == self._config.saturatedDefective:
            nr_px_total = self._nr_px_full_tile - self._nr_px_total_nodata_pixel
        else:
            nr_px_total = self._nr_px_valid
        if nr_px_total > 0:
            fraction = np.float32(nr_px_classified) / np.float32(nr_px_total)
        else:
            fraction = 0
        percentage = np.clip(fraction * 100.0, 0, 100)
        return percentage

    def get_cloud_over_land_percentage(self):
        if (self._tables.hasBand(self._tables.WBI) == True):
            WBI = self._tables.getBand(self._tables.WBI)
            SCL = self._tables.getBand(self._tables.SCL)
            land = ((WBI != 2) & (SCL > self._config.saturatedDefective))
            nr_land_pixels = land.sum()
            if nr_land_pixels > 0:
                SCL_Clouds = (SCL == self._config._medProbaClouds) | (SCL == self._config._highProbaClouds) | (SCL == self._config._thinCirrus)
                nr_cloud_over_land = (SCL_Clouds & land).sum()
                fraction = np.float32(nr_cloud_over_land) / np.float32(nr_land_pixels)
            else:
                fraction = 0
            percentage = np.clip(fraction * 100.0, 0, 100)
            return percentage
        else:
            fraction = 0
            percentage = np.clip(fraction * 100.0, 0, 100)
            return percentage


    def update_qi_report(self, switch_case, qi):
        xp = L2A_XmlParser(self._config, 'QIR')
        qh = xp.getNode('L2A_Quality_Header')
        if self._config.get_operation_mode() == 'TOOLBOX':
            qh.Fixed_Header.File_Class._setText('USER')
            dir = self._config.L2A_UP_DIR
        else:
            qh.Fixed_Header.File_Class._setText('OPER')
            dir = self._config.granule_dir
        creation_date = 'UTC=' + strftime('%Y-%m-%dT%H:%M:%S', datetime.utcnow().timetuple())
        qh.Fixed_Header.Source.Creation_Date._setText(creation_date)
        qh.Fixed_Header.Mission._setText(self._mission_id)
        url_path = os.path.join(dir, 'GRANULE', self._config.L2A_TILE_ID)
        breaker = False
        try:
            db = xp.getNode('Data_Block')
            db.report.attrib['gippVersion'] = self._config._processorVersion
            db.report.attrib['date'] = self._config._processorDate.replace('.','-') + 'T00:00:00Z'
            for checklist in db.report.checkList:
                checklist.item.attrib['name'] = self._config.L2A_TILE_ID
                if qi == 'AUX_DATA_QUALITY':
                    checklist.item.attrib['url'] = os.path.join(url_path, 'AUX_DATA')
                else:
                    checklist.item.attrib['url'] = os.path.join(url_path, 'IMG_DATA', 'R20')
                if checklist.name == qi:
                    breaker = True
                    for check in checklist.check:
                        for value in check.extraValues.value:
                            #print value.attrib['name']
                            value_text = str(switch_case.get(value.attrib['name'],'NA'))
                            value._setText(value_text)
                            #print value_text
                if breaker: break
        except:
            self._config.logger.error("Error in modifying Quality Report data")
        xp.export()
        if xp.validate():
            return True
        else:
            return False

    def update_qi_metadata(self, switch_case, metadata_id):
        xp = L2A_XmlParser(self._config, metadata_id)
        qualityIndicatorsInfo = 'Quality_Indicators_Info'
        imageContentQI = 'Image_Content_QI'

        if metadata_id == 'UP2A':
            cca = xp.getTree(qualityIndicatorsInfo, 'Cloud_Coverage_Assessment')
            cca._setText(str(switch_case.get('CLOUDY_PIXEL_PERCENTAGE', 'NA')))
            if self._config.productVersion >= np.float32(14.8):
                qii2a = xp.getRoot(qualityIndicatorsInfo)
                scaq = xp.getTree(qualityIndicatorsInfo, 'Snow_Coverage_Assessment')
                qii2a.remove(scaq)
        try:
            test = True
            qii = xp.getRoot(qualityIndicatorsInfo)
            icqi = xp.getTree(qualityIndicatorsInfo, imageContentQI)
            if not icqi:
                icqi = objectify.Element(imageContentQI)
                test = False
            if self._config.productVersion > np.float32(14.6):
                if metadata_id == 'T2A':
                    del icqi.DEGRADED_MSI_DATA_PERCENTAGE
                    icqi.CLOUDY_PIXEL_PERCENTAGE = switch_case.get('CLOUDY_PIXEL_PERCENTAGE', 'NA')
                    icqi.CLOUDY_PIXEL_OVER_LAND_PERCENTAGE = switch_case.get('CLOUDY_PIXEL_OVER_LAND_PERCENTAGE', 'NA')
                    icqi.DEGRADED_MSI_DATA_PERCENTAGE = switch_case.get('DEGRADED_MSI_DATA_PERCENTAGE', 'NA')
                else:
                    icqi.CLOUDY_PIXEL_OVER_LAND_PERCENTAGE = switch_case.get('CLOUDY_PIXEL_OVER_LAND_PERCENTAGE', 'NA')
            if self._config.productVersion >= np.float32(14.8) and metadata_id == 'T2A':
                del icqi.SNOW_PIXEL_PERCENTAGE
            icqi.NODATA_PIXEL_PERCENTAGE = switch_case.get('NODATA_PIXEL_PERCENTAGE', 'NA')
            icqi.SATURATED_DEFECTIVE_PIXEL_PERCENTAGE = switch_case.get('SATURATED_DEFECTIVE_PIXEL_PERCENTAGE', 'NA')
            icqi.DARK_FEATURES_PERCENTAGE = switch_case.get('DARK_FEATURES_PERCENTAGE', 'NA')
            icqi.CLOUD_SHADOW_PERCENTAGE = switch_case.get('CLOUD_SHADOW_PERCENTAGE', 'NA')
            icqi.VEGETATION_PERCENTAGE = switch_case.get('VEGETATION_PERCENTAGE', 'NA')
            icqi.NOT_VEGETATED_PERCENTAGE = switch_case.get('NOT_VEGETATED_PERCENTAGE', 'NA')
            icqi.WATER_PERCENTAGE = switch_case.get('WATER_PERCENTAGE', 'NA')
            icqi.UNCLASSIFIED_PERCENTAGE = switch_case.get('UNCLASSIFIED_PERCENTAGE', 'NA')
            icqi.MEDIUM_PROBA_CLOUDS_PERCENTAGE = switch_case.get('MEDIUM_PROBA_CLOUDS_PERCENTAGE', 'NA')
            icqi.HIGH_PROBA_CLOUDS_PERCENTAGE = switch_case.get('HIGH_PROBA_CLOUDS_PERCENTAGE', 'NA')
            icqi.THIN_CIRRUS_PERCENTAGE = switch_case.get('THIN_CIRRUS_PERCENTAGE', 'NA')
            icqi.SNOW_ICE_PERCENTAGE = switch_case.get('SNOW_ICE_PERCENTAGE', 'NA')
            icqi.RADIATIVE_TRANSFER_ACCURACY = 0.0
            icqi.WATER_VAPOUR_RETRIEVAL_ACCURACY = 0.0
            icqi.AOT_RETRIEVAL_ACCURACY = 0.0
            if self._config.productVersion > np.float32(14.6):
                icqi.AOT_RETRIEVAL_METHOD = switch_case.get('AOT_RETRIEVAL_METHOD', 'NA')
                icqi.GRANULE_MEAN_AOT = switch_case.get('GRANULE_MEAN_AOT', 'NA')
                icqi.GRANULE_MEAN_WV = switch_case.get('GRANULE_MEAN_WV', 'NA')
                icqi.OZONE_SOURCE = switch_case.get('OZONE_SOURCE', 'NA')
                icqi.OZONE_VALUE = switch_case.get('OZONE_VALUE', 'NA')
            if test:
                qii.insert(1,icqi)
            else:
                qii.append(icqi)
            return xp.export()
        except:
            self._config.logger.error('Update of quality metadata failed')
            return False
