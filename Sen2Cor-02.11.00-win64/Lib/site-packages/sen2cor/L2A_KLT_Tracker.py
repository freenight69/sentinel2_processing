#! /usr/bin/env python
# -*- coding: utf-8 -*-
# V. Debaecker (TELESPAZIO France)
# modified by J. Louis (TELESPAZIO France) on 11/06/2020
# code cleaning for Sen2Cor version 2.10 on 16/06/2021
  
import numpy as np
import cv2
import datetime as dt
from scipy import interpolate
from scipy.ndimage.morphology import *
from scipy.ndimage.filters import gaussian_filter
from skimage.transform import resize as skit_resize

def KLT_Tracker_points(reference, imagedata, mask, maxCorners=20000, minDistance=5, matching_winsize=25): # dense mindistanc =5 default

    # compute the initial point set
    # goodFeaturesToTrack input parameters
    feature_params = dict(maxCorners=maxCorners, qualityLevel=0.1, minDistance=5, blockSize=15) # dense
    # goodFeaturesToTrack corner extraction-ShiThomasi Feature Detector
    p0 = cv2.goodFeaturesToTrack(reference, mask=mask, **feature_params)
    if p0 is None:
        print("No features extracted")
        return None, None, None, None

    # define KLT parameters-for matching
    #print("Using window of size {} for matching.".format(matching_winsize))
    lk_params = dict(winSize=(matching_winsize, matching_winsize),
                     maxLevel=1,
                     criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 30, 0.03))  # LSM input parameters - termination criteria for corner estimation/stopping criteria

    p1, st, err = cv2.calcOpticalFlowPyrLK(reference, imagedata, p0, None, **lk_params)  # LSM image matching- KLT tracker
    p0r, st, err = cv2.calcOpticalFlowPyrLK(imagedata, reference, p1, None, **lk_params)  # LSM image matching- KLT tracker

    d = abs(p0 - p0r).reshape(-1, 2).max(-1)
    back_threshold = 0.1
    st = d < back_threshold

    #print("Nb Bad Status: {} ".format(len(st[st == 0])))

    # filter with status
    st_valid = 1
    Ninit = len(p0)
    p0 = p0[st == st_valid]
    p1 = p1[st == st_valid]
    err = err[st == st_valid]
    d = d[st == st_valid]
    score = (1 - d/back_threshold)
    x0 = p0[:, 0, 0].reshape(len(p0))
    y0 = p0[:, 0, 1].reshape(len(p0))
    x1 = p1[:, 0, 0].reshape(len(p1))
    y1 = p1[:, 0, 1].reshape(len(p1))

    # radial error
    dx = x1 - x0
    dy = y1 - y0
    dr = np.sqrt(abs(dx) ** 2 + abs(dy) ** 2)

    return x0, y0, dr, Ninit


def compute_cloud_height_image(img_box, ref_box, mask_box):

    starttime = dt.datetime.utcnow()
    rows, columns = img_box.shape
    # laplacian
    img_box = cv2.Laplacian(img_box, cv2.CV_8U, ksize=5)
    ref_box = cv2.Laplacian(ref_box, cv2.CV_8U, ksize=5)

    mask_box = mask_box.astype(np.uint8)

    # KLT - adapt maxCorners parameters to nb of valid pixels
    maxCorners = 1000000
    #print("maxCorners", maxCorners)
    x0, y0, dr, Ninit = KLT_Tracker_points(ref_box, img_box, mask_box, maxCorners=maxCorners, minDistance=5, matching_winsize=25)
    #print('KLT tracker points done.')
    
    #points = np.array([y0, x0]).T
    points = np.array([x0, y0]).T

    if points.size == 0:  # fix of SCOR-50 for tiles with very few pixels: function returns empty array
        return np.array([])

    if rows == 1830:
        # Standard processing:
        resolution = 60.0
        #grid_x, grid_y = np.mgrid[0:columns, 0:rows]
        grid_y, grid_x = np.mgrid[0:rows, 0:columns]
        err_interp = interpolate.griddata(points, 100*dr, (grid_x, grid_y), method='nearest')

    else:
        # Fast processing for S2PDGS operations: points interpolation is performed at 40 m instead of 20 m
        resolution = 20.0
        half_columns = columns / 2
        half_rows = rows / 2
        #grid_x, grid_y = np.mgrid[0:half_columns, 0:half_rows]
        grid_y, grid_x = np.mgrid[0:half_rows, 0:half_columns]
        err_interp = interpolate.griddata(points/2.0, 100*dr, (grid_x, grid_y), method='nearest')
        err_interp = (skit_resize(err_interp, ([rows, columns]), order=1, preserve_range=True)).astype(np.uint16)

    #print('KLT tracker points interpolated.')

    parallax = 0.012

    err_clouds = np.zeros(err_interp.shape).astype(np.uint16)
    err_clouds[(mask_box != 0)] = err_interp[(mask_box != 0)]

    err_clouds_postprocessed = grey_dilation(err_clouds, size=(6, 6))
    err_clouds_postprocessed = gaussian_filter(err_clouds_postprocessed, 5)
    clouds_height = err_clouds_postprocessed / 100.0 * resolution / parallax

    print("Cloud heights processed in {0} seconds".format(dt.datetime.utcnow() - starttime))
    
    return clouds_height.astype(np.uint16)


def compute_cloud_height_stats(img_box, ref_box, mask_box):

    starttime = dt.datetime.utcnow()
    rows, columns = img_box.shape
    if rows == 1830:
        resolution = 60.0
    else:
        resolution = 20.0
    # laplacian
    img_box = cv2.Laplacian(img_box, cv2.CV_8U, ksize=5)
    ref_box = cv2.Laplacian(ref_box, cv2.CV_8U, ksize=5)

    mask_box = mask_box.astype(np.uint8)

    # KLT - adapt maxCorners parameters to nb of valid pixels
    maxCorners = 1000000
    #print("maxCorners", maxCorners)
    x0, y0, dr, Ninit = KLT_Tracker_points(ref_box, img_box, mask_box, maxCorners=maxCorners, minDistance=5, matching_winsize=25)
    #print('KLT tracker points done.')

    if x0 is None:
        print('no KLT tracker points found with this cloud mask.')
        return [1]

    #resolution = 20.0
    parallax = 0.012

    #plt.hist(dr*20./0.012, np.arange(150)*20./0.012/50.)

    if len(dr) > 0:

        clouds_height = dr * resolution / parallax
        clouds_height_mean = clouds_height.mean()
        clouds_height_std = clouds_height.std()
        clouds_height_min = clouds_height.min()
        clouds_height_max = clouds_height.max()
        clouds_height_number = len(clouds_height)

        #print("Cloud height statistics processed in {0} seconds".format(dt.datetime.utcnow() - starttime))

        return [clouds_height_mean, clouds_height_std, clouds_height_min, clouds_height_max, clouds_height_number]

    else:

        return [1]

