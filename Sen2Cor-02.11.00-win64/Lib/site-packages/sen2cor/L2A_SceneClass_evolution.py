#!/usr/bin/env python
from numpy import *
from scipy.ndimage.morphology import *
from scipy.ndimage.interpolation import *
from scipy.ndimage.filters import median_filter, gaussian_filter, sobel
from scipy import ndimage
from L2A_Library import *
from multiprocessing import Lock
import cPickle as pickle
import os
import glymur
import L2A_KLT_Tracker
from skimage.measure import block_reduce
from skimage.morphology import disk
import scipy.stats as stats

l = Lock()
set_printoptions(precision=7, suppress=True)


class L2A_SceneClass(object):
    def __init__(self, config, tables):
        self._notClassified = 100
        self._notSnow = 50
        self._config = config
        self._tables = tables
        self._logger = config.logger
        x = self.config.nrows
        y = self.config.ncols
        self.classificationMask = ones_like(tables.getBand(self.tables.B02), dtype=ubyte) * self._notClassified
        self.confidenceMaskSnow = zeros_like(self.classificationMask)
        self.confidenceMaskCloud = zeros_like(self.classificationMask)
        self._meanShadowDistance = 0
        self._maxShadowDistance = 0.9
        self._arrayDistance = zeros((x, y), float32)
        self.filter = None
        self.LOWEST = 0.000001
        self._noData = self.config.noData
        self._saturatedDefective = self.config.saturatedDefective
        self._darkFeatures = self.config.darkFeatures
        self._cloudShadows = self.config.cloudShadows
        self._vegetation = self.config.vegetation
        self._bareSoils = self.config.bareSoils
        self._water = self.config.water
        self._lowProbaClouds = self.config.lowProbaClouds
        self._medProbaClouds = self.config.medProbaClouds
        self._highProbaClouds = self.config.highProbaClouds
        self._thinCirrus = self.config.thinCirrus
        self._snowIce = self.config.snowIce
        self._darkNotShadow = 13
        self._cloudCoverage = 12
        self.logger.debug('Module L2A_SceneClass initialized')
        self._processingStatus = True
        self._sumPercentage = 0.0
        self._numcall = 0
        self._T_B10_Land = self.config.T1_B10

    def get_logger(self):
        return self._logger

    def set_logger(self, value):
        self._logger = value

    def del_logger(self):
        del self._logger
        
    def get_config(self):
        return self._config

    def get_tables(self):
        return self._tables

    def set_config(self, value):
        self._config = value

    def set_tables(self, value):
        self._tables = value

    def del_config(self):
        del self._config

    def del_tables(self):
        del self._tables

    tables = property(get_tables, set_tables, del_tables, "tables's docstring")
    config = property(get_config, set_config, del_config, "config's docstring")
    logger = property(get_logger, set_logger, del_logger, "logger's docstring")

    def preprocess(self):
        # fix for SIIMPC-1006.1 UMW:
        CM = self.classificationMask
        if self.config.qltmask is True and self.tables.hasBand(self.tables.QMS) is True:
            quality_mask=self.tables.getBand(self.tables.QMS)
            yTop, xLeft, yBottom, xRight = self.config.get_region_of_interest()
            CM[quality_mask[yTop:yBottom,xLeft:xRight]==1] = self._saturatedDefective
        bandIndex = self.tables.bandIndex
        for i in bandIndex:
            band = self.tables.getBand(i)
            CM[band == 0] = self._noData
        if CM[CM>self._saturatedDefective].size == 0:
            self.logger.warning('All images contain only invalid pixels, processing will terminate')
            return False

        return True

    def postprocess(self):
        if(self._processingStatus == False):
            return False
        CM = self.classificationMask
        CM[(CM == self._notClassified)] = self._bareSoils  # modification JL20190329
        value = self.config.medianFilter
        if(value > 0):
            CM = median_filter(CM, value)
            self.logger.info('Filtering output with level: ' + str(value))
        # SIIMPC-1392: QI datamasks should use the same no_data_mask as Scene Classification:
        self.confidenceMaskSnow[(CM == self._noData) | (CM == self._saturatedDefective)] = 0
        self.confidenceMaskCloud[(CM == self._noData) | (CM == self._saturatedDefective)] = 0
        self.logger.info('Storing final Classification Mask')
        self.tables.setBand(self.tables.SCL,(CM).astype(uint8))
        self.logger.info('Storing final Snow Confidence Mask')
        self.tables.setBand(self.tables.SNW,(self.confidenceMaskSnow*100+0.5).astype(uint8))
        self.logger.info('Storing final Cloud Confidence Mask')
        self.tables.setBand(self.tables.CLD,(self.confidenceMaskCloud*100+0.5).astype(uint8))

        picFn = self.config.picFn
        self.config.logger = None
        try:
            f = open(picFn, 'wb')
            pickle.dump(self.config, f, 2)
            f.close()
            self.config.logger = self.logger
        except:
            self.config.logger = self.logger
            self.logger.fatal('cannot update configuration' % picFn)

        self.config.timestamp('Post process  ')
        return

    @property
    def postprocessnew(self):
        if(self._processingStatus == False):
            return False

        CM = self.classificationMask
        CM[(CM == self._notClassified)] = self._bareSoils  # modification JL20190329
        value = self.config.medianFilter
        if(value > 0):
            CM = median_filter(CM, value)
            self.logger.info('Filtering output with level: ' + str(value))
        # SIIMPC-1392: QI datamasks should use the same no_data_mask as Scene Classification:
        self.confidenceMaskSnow[(CM == self._noData) | (CM == self._saturatedDefective)] = 0
        self.confidenceMaskCloud[(CM == self._noData) | (CM == self._saturatedDefective)] = 0

        # Dilatation of Cloud mask: 80 m (buffer size = 9)
        # Dilatation of Cloud shadow mask: 40 m (buffer size = 5)
        # Dilatation of Snow mask: 20 m (buffer size = 3)

        def filter_isolated_cells(image, npix, struct):
            """ Return array with completely isolated single cells removed
            :param image: Array with completely isolated single cells
            :param struct: Structure array for generating unique regions
            :param npix: number of isolated pixels
            :return: Array with minimum region size > 1
            """
            filtered_image = copy(image)
            id_regions, num_ids = ndimage.label(filtered_image, structure=struct)
            id_sizes = array(ndimage.sum(image, id_regions, range(num_ids + 1)))
            area_mask = (id_sizes <= npix)  # filter group of less than 4-connected pixels for npix = 3
            filtered_image[area_mask[id_regions]] = 0

            return filtered_image

        # Clouds Dilation
        # Clouds class limited to (CM == self._medProbaClouds) | (CM == self._highProbaClouds)
        # Thin cirrus class dilated independently with lower priority:
        # Dilation clouds > Dilation Thin cirrus > Other classes

        CM_Clouds = (CM == self._medProbaClouds) | (CM == self._highProbaClouds)
        #CM_Clouds = (CM == self._highProbaClouds)

        # Filtering shoreline regions
        # Shoreline processing to avoid dilation of false detection of cloud pixels
        buffersize = 13    # corresponds to + 120 m dilation buffer around water shoreline detected in SCL
        sx = sobel((CM == self._water), axis=0, mode='constant')
        sy = sobel((CM == self._water), axis=1, mode='constant')
        water_sobel = (sx + sy) > 0
        water_sobel = binary_dilation(water_sobel, ones((buffersize, buffersize)))

        WBI = self.tables.getBand(self.tables.WBI)
        sx = sobel(WBI, axis=0, mode='constant')
        sy = sobel(WBI, axis=1, mode='constant')
        wbi_sobel = (sx + sy) > 0
        buffersize = 15    # corresponds to + 140 m dilation buffer around pixels
        water_sobel = water_sobel & binary_dilation(wbi_sobel, ones((buffersize, buffersize)))

        # Keep large clouds ( > 1000 pixels @ 20m) over Urban area for cloud dilation
        blob_size = 1000 # check if 60 m resolution needs to be handled.
        mask_large_urban_clouds = zeros(CM.shape).astype('bool')

        LCM = self.tables.getBand(self.tables.LCM)
        UrbanCCIDIL = binary_dilation((LCM == 190), structure=disk(9))
        label_cloud_mask, nb_labels = ndimage.label(CM_Clouds & UrbanCCIDIL)
        hist_label_cloud_mask, hist_label_cloud_mask_edges = histogram(label_cloud_mask, bins=arange(label_cloud_mask.max()+2)-0.5)
        list_of_large_blobs = where(hist_label_cloud_mask[1:] > blob_size)[0] + 1  # Discard background = 0 (first index of histogram)
        label_cloud_mask_ravel = ravel(label_cloud_mask.copy())
        ravel(mask_large_urban_clouds)[in1d(label_cloud_mask_ravel, list_of_large_blobs)] = True

        # Filtering over Urban area and bright areas (source ESA LC CCI): no cloud dilation on these zones
        #LCM = self.tables.getBand(self.tables.LCM)
        NotUrbanorNotBright = (~UrbanCCIDIL) | ((LCM < 200) & (LCM > 202))

        # Filtering over snow/soil boundaries zones: no cloud dilation on these zones
        snow_mask_dil = binary_dilation((CM == self._snowIce), disk(7))
        soil_mask_dil = binary_dilation((CM == self._bareSoils), disk(7))
        NotSnowSoilBoundary = ~(snow_mask_dil & soil_mask_dil) # ~ logical not operator

        # Filtering by cloud probability: no cloud dilation if CMC < CMC_4DIL
        CMC = self.confidenceMaskCloud
        CMC_4DIL = 0.65

        # Global filtering before dilation, no dilation applied on very small clouds
        CM_Clouds_filtered = mask_large_urban_clouds | ((CM_Clouds & (water_sobel == 0) & NotUrbanorNotBright & NotSnowSoilBoundary & (CMC > CMC_4DIL)))
        npix = 3
        structsize = 3
        CM_Clouds_filtered = filter_isolated_cells(CM_Clouds_filtered, npix=npix, struct=ones((structsize, structsize)))

        # Cloud Dilatation square operator
        buffersize = 9    # + 80 m dilation buffer around cloud
        CM_Clouds_filtered_dil = binary_dilation(CM_Clouds_filtered, ones((buffersize, buffersize)))
        CM_Clouds_filtered_dil_med = median_filter(CM_Clouds_filtered_dil, buffersize)
        Diff_dil_med_original = (CM_Clouds_filtered_dil_med | CM_Clouds) ^ CM_Clouds    # keep initial clouds
        CM[(Diff_dil_med_original == 1) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._medProbaClouds  # dilation of CM_Clouds coded as MP Clouds

        # Thin cirrus cloud dilation
        CM_Clouds = (CM == self._thinCirrus)

        CM_Clouds_filtered = filter_isolated_cells(CM_Clouds_filtered, npix=npix, struct=ones((structsize, structsize)))
        CM_Clouds_filtered_dil = binary_dilation(CM_Clouds_filtered, ones((buffersize, buffersize)))
        CM_Clouds_filtered_dil_med = median_filter(CM_Clouds_filtered_dil, buffersize)
        Diff_dil_med_original = CM_Clouds_filtered_dil_med ^ CM_Clouds
        CM[(Diff_dil_med_original == 1) & (CM!=self._noData) & (CM!=self._saturatedDefective) & (CM != self._medProbaClouds) & (CM != self._highProbaClouds)] = self._thinCirrus  # dilation of CM_Clouds coded as thinCirrus

        del CM_Clouds
        del CM_Clouds_filtered
        del CM_Clouds_filtered_dil
        del CM_Clouds_filtered_dil_med
        del Diff_dil_med_original

         # Cloud shadow dilation
        buffersize = 5    # + 40 m dilation buffer around cloud shadow
        CM_Cloud_shadows = (CM == self._cloudShadows)
        CM_Cloud_shadows_filtered = filter_isolated_cells(CM_Cloud_shadows, npix=3, struct=ones((3, 3)))
        CM_Cloud_shadows_filtered_dil = binary_dilation(CM_Cloud_shadows_filtered, ones((buffersize, buffersize)))
        CM_Cloud_shadows_filtered_dil_med = median_filter(CM_Cloud_shadows_filtered_dil, buffersize)
        Diff_dil_med_original = CM_Cloud_shadows_filtered_dil_med ^ CM_Cloud_shadows

        CM_Clouds = (CM == self._medProbaClouds) | (CM == self._highProbaClouds) | (CM == self._thinCirrus)
        CM[(Diff_dil_med_original == 1) & (CM_Clouds != 1) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._cloudShadows # self._saturatedDefective
        #CM[(Diff_dil_med_original == 1) & (CM_Clouds != 1) & (self._arrayDistance > self._maxShadowDistance)] = self._saturatedDefective
        # added condition on msd > self._maxShadowDistance

        # Snow mask dilation
        buffersize = 3    # + 20 m dilation buffer around snow
        # CM_Snow = (CM == self._snowIce)
        CM_Snow = (CM == self._snowIce) & (water_sobel == 0)
        CM_Snow_filtered = filter_isolated_cells(CM_Snow, npix=3, struct=ones((3, 3)))
        CM_Snow_filtered_dil = binary_dilation(CM_Snow_filtered, ones((buffersize, buffersize)))
        CM_Snow_filtered_dil_med = median_filter(CM_Snow_filtered_dil, buffersize)
        Diff_dil_med_original = CM_Snow_filtered_dil_med ^ CM_Snow

        CM_Clouds_and_Shadows = (CM == self._medProbaClouds) | (CM == self._highProbaClouds) | (CM == self._thinCirrus) | (CM == self._cloudShadows)
        CM[(Diff_dil_med_original == 1) & (CM_Clouds_and_Shadows != 1) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._snowIce

        self.logger.info('Storing final Classification Mask')
        self.tables.setBand(self.tables.SCL,(CM).astype(uint8))
        self.logger.info('Storing final Snow Confidence Mask')
        self.tables.setBand(self.tables.SNW,(self.confidenceMaskSnow*100+0.5).astype(uint8))
        self.logger.info('Storing final Cloud Confidence Mask')
        self.tables.setBand(self.tables.CLD,(self.confidenceMaskCloud*100+0.5).astype(uint8))

        picFn = self.config.picFn
        self.config.logger = None
        try:
            f = open(picFn, 'wb')
            pickle.dump(self.config, f, 2)
            f.close()
            self.config.logger = self.logger
        except:
            self.config.logger = self.logger
            self.logger.fatal('cannot update configuration' % picFn)

        self.config.timestamp('Post process with dilation of clouds, cloud shadows, snow masks')
        return

    def __exit__(self):
        sys.exit(-1)

    def __del__(self):
        self.logger.info('Module L2A_SceneClass deleted')

    def L2A_CSND_1_1(self):
        # Step 1a: Brightness threshold on red (Band 4)
        T1_B04 = self.config.T1_B04
        T2_B04 = self.config.T2_B04
        T1_B08 = 0.04
        T2_B08 = 0.15
        T1 = 0.1 # Check influence of T1 with test B04<T1
        B04 = self.tables.getBand(self.tables.B04)
        B08 = self.tables.getBand(self.tables.B8A)
        self.confidenceMaskCloud = clip(B04, T1_B04, T2_B04)
        self.confidenceMaskCloud = ((self.confidenceMaskCloud - T1_B04)/(T2_B04-T1_B04))**2
        #JL20151217 self.confidenceMaskCloud = ((self.confidenceMaskCloud - T1_B04)/(T2_B04-T1_B04))
        CM = self.classificationMask
        CM[(B04<T1) & (B08>T1_B08) & (B08<T2_B08) & (CM==self._notClassified) & \
           (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._darkFeatures
        self.confidenceMaskCloud[(CM == self._darkFeatures)] = 0
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 1.1'))
        return

    def L2A_CSND_1_2(self):
        # Step 1b: Normalized Difference Snow Index (NDSI)
        T1_NDSI_CLD = self.config.T1_NDSI_CLD
        T2_NDSI_CLD = self.config.T2_NDSI_CLD
        #JL20151217 f1 = self.confidenceMaskCloud > 0
        B03 = self.tables.getBand(self.tables.B03)
        B11 = self.tables.getBand(self.tables.B11)
        NDSI = (B03 - B11) / maximum((B03 + B11), self.LOWEST)
        CMC = clip(NDSI, T1_NDSI_CLD, T2_NDSI_CLD)
        CMC = ((CMC - T1_NDSI_CLD)/(T2_NDSI_CLD-T1_NDSI_CLD))
        CM = self.classificationMask
        CM[(CMC==0) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notClassified
        self.confidenceMaskCloud *= CMC
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 1.2'))
        return

    def L2A_CSND_2_0(self):
        return

    def L2A_CSND_2_1(self):
        # Snow filter 1: Normalized Difference Snow Index (NDSI)
        T1_NDSI_SNW = self.config.T1_NDSI_SNW
        T2_NDSI_SNW = self.config.T2_NDSI_SNW
        B03 = self.tables.getBand(self.tables.B03)
        B11 = self.tables.getBand(self.tables.B11)
        NDSI = (B03 - B11) / maximum((B03 + B11), self.LOWEST)
        CMS = clip(NDSI, T1_NDSI_SNW, T2_NDSI_SNW)
        CMS = ((CMS - T1_NDSI_SNW)/(T2_NDSI_SNW-T1_NDSI_SNW))
        
        # JL20151217 snow filter applied only on potential clouds
        # JL20170809 usage of ESA CCI Snow Condition Map to exclude additional pixels
        CMC = self.confidenceMaskCloud
        CM = self.classificationMask
        CMS[(CMC == 0) & (CM != self._noData) & (CM!=self._saturatedDefective)] = 0  # exclude non potential cloud from snow probability

        if self.tables.hasBand(self.tables.SNC) is True:
            SNC = self.tables.getBand(self.tables.SNC)

            # exclude no snow pixels from ESA CCI Snow Condition Map
            # Disabled for now 2.6.3. In next versions exclude only non Tropical regions: lat != [-30, 30]
            # because SNC file not accurate enough for rare events, e.g. Snow in Washington DC 2018 March 22
            #CMS[(SNC == 0) & (CM != self._noData)] = 0

            # exclude water pixels from ESA CCI Snow Condition Map only if mean of no water pixel is < 10.0
            # (TBD if Water Bodies Map could be used here also to improve coastline definition)
            if SNC[SNC != 254].sum() > 0:  # Enter only if tile is not full of sea pixels
                if SNC[SNC != 254].mean() < 10.0:
                    CMS[(SNC == 254) & (CM != self._noData) & (CM!=self._saturatedDefective)] = 0
        # end JL20151217 snow filter applied only on potential clouds
        # end JL20170809 usage of ESA CCI Snow Condition Map to exclude additional pixels

        CM = self.classificationMask
        CM[(CMS == 0) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notSnow
        self.confidenceMaskSnow = CMS
        return

    def L2A_CSND_2_1bis(self):
        # New threshold using Band 5 and Band 8 to limit false snow detection
        T2_SNOW_R_B05_B8A = 0.85  # was 1.0. Updated because too much "frozen ground"was omitted 
        B05 = self.tables.getBand(self.tables.B05)
        B8A = self.tables.getBand(self.tables.B8A)
        Ratio_B05B8A = B05 / maximum(B8A, self.LOWEST)
        
        # Exclude potential snow pixels satisfying the condition         
        self.confidenceMaskSnow[(Ratio_B05B8A<T2_SNOW_R_B05_B8A)]= 0     
     
        CM = self.classificationMask
        CM[(self.confidenceMaskSnow == 0) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notSnow
        return

    def L2A_CSND_2_2(self):
        # Snow filter 2: Band 8 thresholds
        T1_B8A = self.config.T1_B8A
        T2_B8A = self.config.T2_B8A
        B8A = self.tables.getBand(self.tables.B8A)
        CMS = clip(B8A, T1_B8A, T2_B8A)
        CMS = ((CMS - T1_B8A) / (T2_B8A - T1_B8A))
        CM = self.classificationMask
        CM[(CMS == 0) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notSnow
        self.confidenceMaskSnow *= CMS
        return

    def L2A_CSND_2_3(self):
        # Snow filter 3: Band 2 thresholds
        T1_B02 = self.config.T1_B02
        T2_B02 = self.config.T2_B02
        B02 = self.tables.getBand(self.tables.B02)
        CMS = clip(B02, T1_B02, T2_B02)
        CMS = ((CMS - T1_B02) / (T2_B02 - T1_B02))
        CM = self.classificationMask
        CM[(CMS == 0) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notSnow
        self.confidenceMaskSnow *= CMS
        return

    def L2A_CSND_2_4(self):
        # Snow filter 4: Ratio Band 2 / Band 4
        T1_R_B02_B04 = self.config.T1_R_B02_B04
        T2_R_B02_B04 = self.config.T2_R_B02_B04
        B02 = self.tables.getBand(self.tables.B02)
        B04 = self.tables.getBand(self.tables.B04)
        RB02_B04 = B02 / maximum(B04,self.LOWEST)
        CMS = clip(RB02_B04, T1_R_B02_B04, T2_R_B02_B04)
        CMS = ((CMS - T1_R_B02_B04) / (T2_R_B02_B04 - T1_R_B02_B04))
        CM = self.classificationMask
        CM[(CMS == 0) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notSnow
        self.confidenceMaskSnow *= CMS
        CM = self.classificationMask
        return

    def L2A_CSND_2_5(self):
        # CHECK RING ALGORITHM THAT WAS NOT IMPLEMENTED BEFORE THIS VERSION.
        # Snow filter 5: snow boundary zones
        T1_SNOW = self.config.T1_SNOW
        T2_SNOW = self.config.T2_SNOW
        B12 = self.tables.getBand(self.tables.B12)
        CM = self.classificationMask
        CMS = self.confidenceMaskSnow
        snow_mask = (CMS >T1_SNOW) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[snow_mask] = self._snowIce
        # Dilatation cross-shape operator (5x5)
        struct = iterate_structure(generate_binary_structure(2,1), 3)
        snow_mask_dil = binary_dilation(snow_mask, struct)
        ring = snow_mask_dil ^ snow_mask
        ring_no_clouds = (ring & (B12 < T2_SNOW))
        # important, if classified as snow, this should not become cloud:
        self.confidenceMaskCloud[ring_no_clouds | (CM == self._snowIce)] = 0
        # release the lock for the non snow classification
        CM[(CM == self._notSnow) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._notClassified
        return

    def L2A_SnowPostProcessingCCI(self):
        if self.tables.hasBand(self.tables.SNC) is True:
            SNC = self.tables.getBand(self.tables.SNC)
            CM = self.classificationMask
            CMS = self.confidenceMaskSnow
            CMC = self.confidenceMaskCloud

            # exclude no snow pixels from ESA CCI Snow Condition Map
            # Enable in 2.10 with refined Monthly Snow Conditions Maps
            subset_nosnow = ((SNC == 0) | (SNC == 255)) & (CM == self._snowIce) & (CM!=self._noData) & (CM!=self._saturatedDefective) # SNC no snow (0) and Nan values (255)
            CM[subset_nosnow] = self._medProbaClouds   # snow pixels reverted to medProbaClouds in SCL map (based on subset_nosnow filter)
            CMS[subset_nosnow] = 0  # snow probability set to 0
            CMC[subset_nosnow] = 0.50  # cloud probability set to 0.50

            # exclude water pixels from ESA CCI Snow Condition Map only if mean of no water pixel is < 10.0
            # (TBD if Water Bodies Map could be used here also to improve coastline definition)
            if (SNC != 254).sum() > 0:  # Enter only if tile is not full of sea pixels
                if SNC[(SNC != 254)].mean() < 10.0:
                    CM[(SNC == 254) & (CM == self._snowIce) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._medProbaClouds  # snow set to medProbaClouds
                    CMS[(SNC == 254) & (CM == self._snowIce) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = 0  # snow probability set to 0

        return

    def L2A_CSND_3(self):
        # Step 3: Normalized Difference Vegetation Index (NDVI)
        T1_NDVI = self.config.T1_NDVI
        T2_NDVI = self.config.T2_NDVI
        T1_B2T = 0.15
        B02 = self.tables.getBand(self.tables.B02)
        B04 = self.tables.getBand(self.tables.B04)
        B8A = self.tables.getBand(self.tables.B8A)
        NDVI = (B8A - B04) / maximum((B8A + B04), self.LOWEST)
        CMC = clip(NDVI, T1_NDVI, T2_NDVI)
        CMC = ((CMC - T1_NDVI)/(T2_NDVI-T1_NDVI))
        CM = self.classificationMask
        CM[(CMC==1) & (CM == self._notClassified) & (B02 < T1_B2T) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._vegetation
        CMC[(CM== self._vegetation)] = 0
        FLT = [(CMC>0) & (CMC < 1.0)]
        CMC[FLT] = CMC[FLT] * -1 + 1
        self.confidenceMaskCloud[FLT] *= CMC[FLT]
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 3'))
        return

    def L2A_CSND_4(self):
        # Step 4: Ratio Band 8 / Band 3 for senescing vegetation
        T1_R_B8A_B03 = self.config.T1_R_B8A_B03
        T2_R_B8A_B03 = self.config.T2_R_B8A_B03
        B03 = self.tables.getBand(self.tables.B03)
        B8A = self.tables.getBand(self.tables.B8A)
        rb8b3 = B8A/maximum(B03,self.LOWEST)
        CMC = clip(rb8b3, T1_R_B8A_B03 , T2_R_B8A_B03)
        CMC = (CMC - T1_R_B8A_B03 ) / (T2_R_B8A_B03 - T1_R_B8A_B03 )
        CM = self.classificationMask
        CM[(CMC==1) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._vegetation
        CMC[(CM== self._vegetation)] = 0
        FLT = [(CMC>0) & (CMC < 1.0)]
        CMC[FLT] = CMC[FLT] * -1 + 1
        self.confidenceMaskCloud[FLT] *= CMC[FLT]
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 4'))
        return

    def L2A_CSND_5_1(self):
        # Step 5.1: Ratio Band 2 / Band 11 for soils
        T11_B02 = self.config.T11_B02 # -0.40
        T12_B02 = self.config.T12_B02 #  0.46
        T11_R_B02_B11 = self.config.T11_R_B02_B11 # 0.55 # 0.70
        T12_R_B02_B11 = self.config.T12_R_B02_B11 # 0.80 # 1.0
        B02 = self.tables.getBand(self.tables.B02)
        B11 = self.tables.getBand(self.tables.B11)
        R_B02_B11 = clip((B02/maximum(B11,self.LOWEST)),0,100)
        B02_FT = clip(R_B02_B11*T11_B02+T12_B02, 0.15, 0.32)        
        CM = self.classificationMask
        # Correction JL20151223: condition for bare_soils is on threshold T11_R_B02_B11
        CM[(B02 < B02_FT) & (R_B02_B11 < T11_R_B02_B11) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._bareSoils
        self.confidenceMaskCloud[CM == self._bareSoils] = 0
        CMC = clip(R_B02_B11, T11_R_B02_B11, T12_R_B02_B11)
        CMC = ((CMC - T11_R_B02_B11)/(T12_R_B02_B11-T11_R_B02_B11))
        FLT = (R_B02_B11 > T11_R_B02_B11) & (R_B02_B11 < T12_R_B02_B11) & (B02 < B02_FT) & (CM == self._notClassified)
        self.confidenceMaskCloud[FLT] *= CMC[FLT]
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 5.1'))
        return

    def L2A_CSND_5_2(self):
        # Step 5.2: Ratio Band 2 / Band 11 for water bodies, dependent on Band 12
        T21_B12 = self.config.T21_B12 # 0.1
        T22_B12 = self.config.T22_B12 # -0.09
        T21_R_B02_B11 = self.config.T21_R_B02_B11 # 2.0
        T22_R_B02_B11 = self.config.T22_R_B02_B11 # 4.0
        T_B02 = 0.2 # modif JL water TOA reflectance shall be less than 20%
        B02 = self.tables.getBand(self.tables.B02)
        B11 = self.tables.getBand(self.tables.B11)
        B12 = self.tables.getBand(self.tables.B12)
        B8A = self.tables.getBand(self.tables.B8A) # B8A used for additional condition
        B04 = self.tables.getBand(self.tables.B04) # B04 used for additional condition
        R_B02_B11 = B02 / maximum(B11,self.LOWEST)
        B12_FT = clip(R_B02_B11*T21_B12+T22_B12, 0.07, 0.21)
        # additional condition on B8A and B04 to restrict over detection of water
        R_B02_B11_GT_T22_R_B02_B11 = where((R_B02_B11 > T22_R_B02_B11) & (B12 < B12_FT) & (B8A < B04) & (B02 < T_B02), True, False)
        CM = self.classificationMask # this is a reference, no need to reassign
        CM[R_B02_B11_GT_T22_R_B02_B11 & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._water
        self.confidenceMaskCloud[CM == self._water] = 0
        
        # additional condition on B8A and B04 to restrict over detection of water
        R15_AMB = (R_B02_B11 < T22_R_B02_B11) & (R_B02_B11 >= T21_R_B02_B11) & (B12 < B12_FT) & (B8A < B04) & (B02 < T_B02)
        if(R15_AMB.size > 0):
            a = -1 / (T22_R_B02_B11 - T21_R_B02_B11)
            b = -T21_R_B02_B11 * a + 1
            CMC = a * R_B02_B11[R15_AMB] + b
            self.confidenceMaskCloud[R15_AMB] *= CMC
        
        # second part, modification for improvement of water classification:
        T_24 = 0.034
        DIFF24_AMB = B02-B04
        #CM = self.classificationMask
        F1 = (DIFF24_AMB > T_24) & (B8A < B04) & (B02 < T_B02)
        #F2 = (DIFF24_AMB > T_24) & (B8A < B04) # potential topographic shadow over snow
        CM[F1 & (CM == self._notClassified)] = self._water
        self.confidenceMaskCloud[F1 & (CM == self._water) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = 0
        #self.confidenceMaskCloud[F2 & (CM == self._notClassified)] = 0 # potential topographic shadow over snow
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 5.2'))
        return

    def L2A_CSND_6(self):
        # Step 6: Ratio Band 8 / Band 11 for rocks and sands in deserts
        T1_R_B8A_B11 = self.config.T1_R_B8A_B11 #0.90
        T2_R_B8A_B11 = self.config.T2_R_B8A_B11 #1.10
        T1_B02 = -0.25 
        T2_B02 = 0.475
        T_R_B02_B11 = 0.8
        B02 = self.tables.getBand(self.tables.B02)
        B8A = self.tables.getBand(self.tables.B8A)
        B11 = self.tables.getBand(self.tables.B11)
        R_B8A_B11 = B8A/maximum(B11,self.LOWEST)        
        B02_FT = clip(R_B8A_B11*T1_B02+T2_B02, 0.16, 0.35)        
        
        CM = self.classificationMask # this is a reference, no need to reassign
        # Correction JL20151223: condition for bare_soils is on threshold T1_R_B8A_B11 and B02 < T_R_B02_B11 * B11
        CM[(B02 < B02_FT) & (R_B8A_B11 < T1_R_B8A_B11) & (B02 < T_R_B02_B11*B11) & (CM == self._notClassified)] = self._bareSoils
        self.confidenceMaskCloud[CM == self._bareSoils] = 0  
        CMC = clip(R_B8A_B11, T1_R_B8A_B11, T2_R_B8A_B11)
        CMC = ((CMC - T1_R_B8A_B11)/(T2_R_B8A_B11-T1_R_B8A_B11))
        FLT = (R_B8A_B11 > T1_R_B8A_B11) & (R_B8A_B11 < T2_R_B8A_B11) & (B02 < B02_FT) & \
              (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        if FLT.mean() > 0:
            self.confidenceMaskCloud[FLT] *= CMC[FLT]
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 6'))
        return

    def L2A_CSND_6bis(self):
        # Step 6bis: Ratio Band 4 / Band 11 do discard cloud pixels with very high ratio B4/B11
        T1_R_B04_B11 = 3.0 #self.config.T1_R_B04_B11
        T2_R_B04_B11 = 6.0 #self.config.T2_R_B04_B11
        B04 = self.tables.getBand(self.tables.B04)
        B11 = self.tables.getBand(self.tables.B11)
        rb4b11 = B04/maximum(B11,self.LOWEST)
        CMC = clip(rb4b11, T1_R_B04_B11 , T2_R_B04_B11)
        CMC = (CMC - T1_R_B04_B11 ) / (T2_R_B04_B11 - T1_R_B04_B11 )
        CM = self.classificationMask
        FLT = [(CMC>0) & (CMC < 1.0)]
        CMC[FLT] = CMC[FLT] * -1 + 1
        self.confidenceMaskCloud[(CMC==1) & (CM == self._notClassified) & \
            (CM!=self._noData) & (CM!=self._saturatedDefective)] = 0
        self.confidenceMaskCloud[FLT] *= CMC[FLT]
        self.logger.debug(statistics(self.confidenceMaskCloud, 'CM Cloud step 6bis'))
        return

    def L2A_CSND_7(self):
        T_CLOUD_LP = self.config.T_CLOUD_LP
        T_CLOUD_MP = self.config.T_CLOUD_MP
        T_CLOUD_HP = self.config.T_CLOUD_HP
        T1_B10 = self.config.T1_B10
        T2_B10 = self.config.T2_B10
        B02 = self.tables.getBand(self.tables.B02)
        B10 = self.tables.getBand(self.tables.B10)
        LPC = self._lowProbaClouds
        MPC = self._medProbaClouds
        HPC = self._highProbaClouds
        CIR = self._thinCirrus
        CM = self.classificationMask
        CMC = self.confidenceMaskCloud
        
        REFL_BLUE_MAX = 0.50
        CM[(CMC > T_CLOUD_LP) & (CMC < T_CLOUD_MP) & (CM == self._notClassified)] = LPC
        self.logger.debug(statistics(CMC[(CM == LPC)], 'CM LOW_PROBA_CLOUDS'))
        CM[(CMC >= T_CLOUD_MP) & (CMC < T_CLOUD_HP) & (CM == self._notClassified)] = MPC
        self.logger.debug(statistics(CMC[(CM == MPC)], 'CM MEDIUM_PROBA_CLOUDS'))
        CM[(CMC >= T_CLOUD_HP) & (CM == self._notClassified)] = HPC
        self.logger.debug(statistics(CMC[(CM == HPC)], 'CM HIGH_PROBA_CLOUDS'))
        # Cirrus updated + DEM condition if available:
        if (self.tables.hasBand(self.tables.DEM) is True):
            dem = self.tables.getBand(self.tables.DEM)
        else:
            dem = (ones(CM.shape, dtype = int16) * self.config._altit * 1000).astype(int16)
        T_dem = 1500  # cirrus detection is switched off above 1500m
        CM[(B10 > T1_B10) & (B10 < T2_B10) & (B02 < REFL_BLUE_MAX) & (dem < T_dem) & (CMC < T_CLOUD_MP) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = CIR
        MPC_subset = (B10 >= T2_B10) & (CMC < T_CLOUD_HP) & (CM!=self._noData) & (CM!=self._saturatedDefective) & (dem < T_dem)
        CM[MPC_subset] = MPC
        self.confidenceMaskCloud[MPC_subset] = 0.65
        self.confidenceMaskSnow[MPC_subset] = 0.0
        self.logger.debug(statistics(CMC[(CM == MPC)], 'CM MEDIUM_PROBA_CLOUDS, step2'))
        self.logger.debug(statistics(CMC[(CM == CIR)], 'CM THIN_CIRRUS'))
        return


    def L2A_DarkVegetationRecovery(self):
        CM = self.classificationMask
        B04 = self.tables.getBand(self.tables.B04)
        B8A = self.tables.getBand(self.tables.B8A)
        NDVI = (B8A - B04) / maximum((B8A + B04), self.LOWEST)
        del B04

        T2_NDVI = self.config.T2_NDVI
        F1 = NDVI > T2_NDVI
        del NDVI

        subset = F1 & ((CM == self._darkFeatures) | (CM == self._notClassified)) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[subset] = self._vegetation
        CM[subset] = self._vegetation
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0
        del F1

        T2_R_B8A_B03 = self.config.T2_R_B8A_B03
        B03 = self.tables.getBand(self.tables.B03)
        rb8b3 = B8A/maximum(B03, self.LOWEST)
        del B8A
        del B03
        F2 = rb8b3 > T2_R_B8A_B03
        del rb8b3

        subset = F2 & ((CM == self._darkFeatures) | (CM == self._notClassified)) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[subset] = self._vegetation
        CM[subset] = self._vegetation
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0
        return

    def L2A_WaterPixelRecovery(self):
        # modified 2015 18 12
        # Sentinel-2 B2/B11 ratio > 4.0 and Band 8 < Band 4
        # for unclassified additional condition: Band8 < 0.3 (F4)
        B02 = self.tables.getBand(self.tables.B02)
        B04 = self.tables.getBand(self.tables.B04)
        B8A = self.tables.getBand(self.tables.B8A)
        B11 = self.tables.getBand(self.tables.B11)
        R_B02_B11 = B02/maximum(B11, self.LOWEST)
        del B02
        del B11

        T22_R_B02_B11 = self.config.T22_R_B02_B11  # 4.0
        F3 = R_B02_B11 > T22_R_B02_B11

        T_B8A = 0.3
        F4 = B8A < T_B8A
        CM = self.classificationMask
        CM[F3 & (B8A < B04) & (CM == self._darkFeatures) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._water
        CM[F3 & (B8A < B04) & F4 & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._water
        self.confidenceMaskCloud[F3 & (B8A < B04) & (CM == self._darkFeatures) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = 0.0
        self.confidenceMaskSnow[F3 & (B8A < B04) & F4 & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = 0.0

        return

    def L2A_WaterPixelCleaningwithDEM(self):
        # modified 2015 18 12
        # clean water pixels detected in topographic shadow or steep slopes
        if (self.tables.hasBand(self.tables.DEM) is True):
            slope = self.tables.getBand(self.tables.SLP)
            shadow = self.tables.getBand(self.tables.SDW)
            T_Shadow = 1
            T_Slope = 15
            clean_area = (shadow == T_Shadow) | (slope > T_Slope) # modification with corrected casted shadow algorithm
            CM = self.classificationMask
            subset = clean_area & (CM == self._water) & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._darkFeatures # potential conflict with floods?
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0
        return
        

    def L2A_TopographicShadowwithDEM(self):
        # Process potential topographic shadow over snow/mountainous area and discard water areas from ESA CCI water bodies
        if self.tables.hasBand(self.tables.DEM):
            # Get pixels of topographic shadows from DEM geometry
            T_Shadow = 1
            shadow = self.tables.getBand(self.tables.SDW)
            casted_shadow = (shadow == T_Shadow)
            casted_shadow_dil = binary_dilation(casted_shadow, ones((9, 9)))  # was 5.  WARNING check SKIMAGE MORPHOLOGY!
            casted_shadow_dil = median_filter(casted_shadow_dil, 9)
            CM = self.classificationMask
            
            # identify dark pixels outside of topographic shadows
            dark_not_shadow = (CM == self._darkFeatures) & (~casted_shadow_dil)

            # Get potential pixels of topographic shadows over snow/mountainous area from radiometry
            B02 = self.tables.getBand(self.tables.B02)
            B8A = self.tables.getBand(self.tables.B8A)
            B04 = self.tables.getBand(self.tables.B04)
            T_B02 = 0.20 # modif JL water TOA reflectance shall be less than 20%
            T_24 = 0.034
            DIFF24_AMB = B02-B04
            F2 = (DIFF24_AMB > T_24) & (B8A < B04) & (B02 > T_B02) # potential topographic shadow over snow
            potential_pixels = F2 & ((CM == self._notClassified) | (CM == self._lowProbaClouds) | (CM == self._medProbaClouds))

            # Assign darkFeatures class to topographic shadow (dark pixels + potential topographic shadow over snow, in the area of casted shadow)
            subset = ((CM == self._darkFeatures) | potential_pixels) & casted_shadow & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._darkFeatures
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0

            # Assign darkFeatures class to topographic shadow over water (water pixels in the area of casted shadow)
            subset = (CM == self._water) & casted_shadow & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._darkFeatures
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0

            # Keep darkFeatures class to dark pixels outside of topographic shadows -> shadows ? burned areas ? very low local sun elevation angle ?
            # In the future maybe assign lowProbaClouds class to dark pixels outside of topographic shadows -> confusion with lowProbaClouds

            # if local solar zenith angle > (local solar zenith angle + 5 deg) and sza < 45
            if (self.config._solze_noclip < 45):
                cbeta = shadow/255.
                T_lsza = 5.0 # corresponds to a variation of T_lsza deg of local solar zenith angle
                sza = self.config._solze_noclip
                sza_T_lsza = clip(sza + T_lsza, 0, 90)
                lsza_plus_5deg = cbeta > cos(sza_T_lsza * pi / 180.)
                subset = dark_not_shadow & (CM!=self._noData) & (CM!=self._saturatedDefective) & lsza_plus_5deg
                CM[subset] = self._lowProbaClouds# Assign lowProbaClouds class to dark pixels outside of topographic shadows
                self.confidenceMaskCloud[subset] = 0.0
                self.confidenceMaskSnow[subset] = 0.0

            else:
                subset = dark_not_shadow & (CM!=self._noData) & (CM!=self._saturatedDefective)
                CM[subset] = self._darkNotShadow #self._darkFeatures #self._darkNotShadow #self._lowProbaClouds# Assign _darkNotShadow class to dark pixels outside of topographic shadows
                self.confidenceMaskCloud[subset] = 0.0
                self.confidenceMaskSnow[subset] = 0.0
                #CM[dark_not_shadow & (CM!=self._noData)] = self._darkNotShadow #self._lowProbaClouds

        return

    def L2A_SnowRecovery(self):
        B03 = self.tables.getBand(self.tables.B03)
        B11 = self.tables.getBand(self.tables.B11)
        CM = self.classificationMask
        snow_mask = (CM == self._snowIce)
        struct = iterate_structure(generate_binary_structure(2,1), 3)
        snow_mask_dil = binary_dilation(snow_mask, struct)
        subset = snow_mask_dil & (B11 < B03) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[subset] = self._snowIce
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 1.0
        return


    def L2A_SnowSoilBorders(self): # Mitigate the false cloud detection in soil/snow mixed pixel around snow area. Mitigate false cloud dilation.
        CM = self.classificationMask
        snow_mask = (CM == self._snowIce)
        soil_mask = (CM == self._bareSoils)
        cloud_mask = ((CM == self._medProbaClouds) | (CM == self._highProbaClouds))
        snow_mask_dil = binary_dilation(snow_mask, disk(5))
        soil_mask_dil = binary_dilation(soil_mask, disk(5))
        subset = snow_mask_dil & soil_mask_dil & cloud_mask & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[subset] = self._bareSoils
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0
        return

    def L2A_SoilRecovery(self):
        # modification JL20190322: replace very low probability cloud < 10% by bare_soils <=> not_vegetated
        T4 = 0.65
        T_B11 = 0.080 #T4 is too restricitve and some agricultural fields are classified as dark features maybe additional class could be added.
        B02 = self.tables.getBand(self.tables.B02)
        B11 = self.tables.getBand(self.tables.B11)
        R_B02_B11 = B02/maximum(B11,self.LOWEST)
        #F4 = (R_B02_B11 < T4) | (B11 > T_B11) # enlarge soil recovery to B11 > T_B11
        F4 = (R_B02_B11 < T4) # T_B11 disturbs cloud edges over water. previous line disabled.
        CM = self.classificationMask
        CMC = self.confidenceMaskCloud

        subset = (CMC > 0.0) & (CMC < 0.10) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[subset] = self._bareSoils # modification JL20190327
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0
        subset = F4 & (CM == self._darkFeatures) & (CM!=self._noData) & (CM!=self._saturatedDefective)
        CM[subset] = self._bareSoils  # disabled modification JL20190322
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0
        #CM[(CM == self._notClassified)] = self._bareSoils # modified 2015 12 18
        return

    # def L2A_LandPixelRecoveryB10B09B8A(self):
    #     if (self.tables.hasBand(self.tables.LCM) is True):
    #         LCM = self.tables.getBand(self.tables.LCM)
    #         CM = self.classificationMask
    #         B10 = self.tables.getBand(self.tables.B10)
    #         B8A = self.tables.getBand(self.tables.B8A)
    #         B09 = self.tables.getBand(self.tables.B09)
    #
    #         T_B10_min = 0.0015
    #
    #         resolution = self.config.resolution
    #         blob_size = (300.0/resolution)**2
    #
    #         Land = (CM == self._bareSoils) | (CM == self._vegetation)
    #
    #         # Compute a threshold on B10 band to discard low B10 brightness (close to ground) pixels without removing True clouds
    #         nrEntriesTotal = float32(size(CM[(CM!=self._noData) & (CM!=self._saturatedDefective)]))
    #         HPC_percentage = float32(size(CM[CM == self._highProbaClouds])) / nrEntriesTotal * 100.0
    #         Land_percentage = float32(Land.sum()) / nrEntriesTotal * 100.0
    #
    #         # Discard this routine if Land pixels percentage less than 5 % or Land area less than 121 km2 (11km x 11km)
    #         if (Land_percentage < 5.0) | (Land.sum() < 121e6/resolution**2):
    #             # Not enough Land reference pixels to perform Land pixel recovery
    #             return
    #
    #         if HPC_percentage > 20.0:
    #             T_B10 = max(T_B10_min, min(B10[Land].mean(), B10[(CM == self._highProbaClouds)].mean() - 2 * B10[(CM == self._highProbaClouds)].std()))
    #             T_B10 = min(T_B10, B10[Land].mean())
    #
    #         elif HPC_percentage < 2.0:
    #             #T_B10 = max(T_B10_min, B10[Land].mean() - B10[Land].std())
    #             T_B10 = B10[Land].mean()
    #         else:
    #             # B10 statistics are computed only on clouds larger than 300m x 300m (e.g. 25 pixels at 60 m resolution)
    #             mask_large_HP_clouds = zeros(CM.shape).astype('bool')
    #             label_cloud_mask, nb_labels = ndimage.label(CM == self._highProbaClouds)
    #             hist_label_cloud_mask, hist_label_cloud_mask_edges = histogram(label_cloud_mask, bins=arange(label_cloud_mask.max()+2)-0.5)
    #             list_of_large_blobs = where(hist_label_cloud_mask[1:] > blob_size)[0] + 1  # Discard background = 0 (first index of histogram)
    #             label_cloud_mask_ravel = ravel(label_cloud_mask.copy())
    #             ravel(mask_large_HP_clouds)[in1d(label_cloud_mask_ravel, list_of_large_blobs)] = True
    #             T_B10 = max(T_B10_min, min(T_B10_min, B10[Land].mean(), B10[mask_large_HP_clouds].mean() - 2 * B10[mask_large_HP_clouds].std()))
    #             T_B10 = min(T_B10, B10[Land].mean())
    #
    #         Ratio_B09_B8A = zeros(CM.shape).astype(float32)
    #         Ratio_B09_B8A[(CM!=self._noData) & (CM!=self._saturatedDefective)] = \
    #             float32(B09[(CM!=self._noData) & (CM!=self._saturatedDefective)]) / \
    #             float32(B8A[(CM!=self._noData) & (CM!=self._saturatedDefective)])
    #         mean_Ratio_B09_B8A = Ratio_B09_B8A[Land].mean()
    #         std_Ratio_B09_B8A = Ratio_B09_B8A[Land].std()
    #         T_Ratio_B09_B8A = mean_Ratio_B09_B8A + std_Ratio_B09_B8A
    #
    #         # ESA CCI Land pixel recovery for cloudy pixels with low B10 brightness (close to ground)
    #         subset = (LCM != 210) & ((CM == self._medProbaClouds) | (CM == self._highProbaClouds)) & (B10 < T_B10) & (Ratio_B09_B8A < T_Ratio_B09_B8A) & (CM!=self._noData) & (CM!=self._saturatedDefective)
    #         CM[subset] = self._bareSoils  # all land pixels
    #         self.confidenceMaskCloud[subset] = 0.0
    #         self.confidenceMaskSnow[subset] = 0.0
    #     return

    def L2A_CirrusPixelRecoveryB10(self):
        if (self.tables.hasBand(self.tables.LCM) is True):
            #LCM = self.tables.getBand(self.tables.LCM)
            CM = self.classificationMask
            B10 = self.tables.getBand(self.tables.B10)

            # B10 threshold computation
            # Above Water pixels
            total_water = float((CM == self._water).sum())

            if (total_water != 0):
                mean_B10_water = B10[(CM == self._water)].mean()
                T_B10_Water = min(max(2 * mean_B10_water - percentile(B10[(CM == self._water)], 1), 0.0020), self.config.T1_B10)
                #T_B10_Water = max(B10[(CM == self._water)].mean() + 3 * B10[(CM == self._water)].std(), 0.0020)
                #print ('T_B10_Water = {0}').format(T_B10_Water)
            else:
                T_B10_Water = self.config.T1_B10
                #print ('Default T1_B10: T_B10_Water = {0}').format(T_B10_Water)

            # Above Land pixels update
            total_veg = float((CM == self._vegetation).sum())
            total_not_veg = float((CM == self._bareSoils).sum())
            total_veg_and_not_veg = total_veg + total_not_veg
            Land = (CM == self._bareSoils) | (CM == self._vegetation)

            if (total_veg_and_not_veg != 0):
                percent_veg = float((CM == self._vegetation).sum()) / total_veg_and_not_veg
                percent_not_veg = float((CM == self._bareSoils).sum()) / total_veg_and_not_veg

                if (total_veg != 0):
                    mean_B10_veg = B10[(CM == self._vegetation)].mean()
                    T_B10_veg = min(max(2 * mean_B10_veg - percentile(B10[(CM == self._vegetation)], 1), 0.0030), self.config.T1_B10)
                    #if isnan(mean_B10_veg):
                    #    T_B10_veg = 0.0
                    #    percent_veg = 0.0
                else:
                    T_B10_veg = 0.0
                    percent_veg = 0.0

                if (total_not_veg != 0):
                    mean_B10_not_veg = B10[(CM == self._bareSoils)].mean()
                    T_B10_not_veg = min(max(2 * mean_B10_not_veg - percentile(B10[(CM == self._bareSoils)], 1), 0.0030), self.config.T1_B10)
                    #if isnan(mean_B10_not_veg):
                    #    T_B10_not_veg = 0.0
                    #    percent_not_veg = 0.0
                else:
                    T_B10_not_veg = 0.0
                    percent_not_veg = 0.0

                T_B10_Land = percent_veg * T_B10_veg + percent_not_veg * T_B10_not_veg
                #print ('T_B10_Land = {0}').format(T_B10_Land)
            else:
                T_B10_Land = self.config.T1_B10
                #print ('Default T1_B10: T_B10_Land = {0}').format(T_B10_Land)

            self._T_B10_Land = T_B10_Land # set this external variable to be re-used in parallax algorithm KLT

            if (self.tables.hasBand(self.tables.DEM) is True):
                dem = self.tables.getBand(self.tables.DEM)
                cbeta = self.tables.getBand(self.tables.SDW).astype(float32) / 255.0
                #slp = self.tables.getBand(self.tables.SLP)
                #asp = self.tables.getBand(self.tables.ASP)
                T_dem = 1500  # cirrus detection is switched off above 1500m
                # ESA CCI Cirrus pixel recovery above Land with dem condition
                # check 1: if cirrus distribution over land is balanced or biased like only slopes facing south
                #cbeta[cirrusland].mean()
                # check 2: correct B10 value using local incidence slope and altitude
                sza = self.config._solze_noclip
                cos_sza = cos(sza * pi / 180.)
                B10_correct = B10 * cos_sza / clip(cbeta, cos_sza, 1.0) # correct for local incidence
                B10_correct *= exp((-0.49 - 0.011 * dem / 1000.) * dem / 1000.) # correct for water vapour distribution vs altitude
                #CM[Land & (B10_correct >= T_B10_Land) & (dem < T_dem)] = self._thinCirrus
                #CM[Land & (B10_correct >= T_B10_Land) & (B10_correct < self.config.T2_B10) & (dem < T_dem)] = self._thinCirrus
                CM[(B10_correct >= T_B10_Land) & (B10_correct < self.config.T2_B10) & (dem < T_dem) & (CM != self._medProbaClouds) & (CM != self._highProbaClouds) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._thinCirrus

                # ESA CCI Cirrus pixel recovery above Water with dem condition
                CM[(CM == self._water) & (B10 > T_B10_Water) & (dem < T_dem) & (CM != self._medProbaClouds) & (CM != self._highProbaClouds) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._thinCirrus
            else:
                # ESA CCI Cirrus pixel recovery above Land
                CM[Land & (B10 > T_B10_Land)] = self._thinCirrus # land condition CM?
                # ESA CCI Cirrus pixel recovery above Water
                CM[(CM == self._water) & (B10 > T_B10_Water) & (CM != self._medProbaClouds) & (CM != self._highProbaClouds) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._thinCirrus
        return

    def L2A_FineMorphoRecovery(self, mask, CM, thre_ring_cloudy):
        # label of blobs of binary mask
        label_mask, nb_labels = ndimage.label(mask)

        del(mask)

        # dilatation square operator (3x3)
        label_mask_dil = grey_dilation(label_mask, size=(3, 3))

        # construct the boundary layer, i.e. ring, of each blob
        ring = label_mask_dil - label_mask

        # hist_1: Compute histogram of label values of rings only on valid data
        hist_ring, hist_ring_edges = histogram(ring, bins=arange(ring.max()+2)-0.5)

        # ring intersection with clouds and cloud shadows
        mask_clouds = ((CM == self._lowProbaClouds) | (CM == self._medProbaClouds) | (CM == self._highProbaClouds) | (CM == self._thinCirrus) | (CM == self._cloudShadows))
        ring_cloudy = int32(zeros(CM.shape))
        ring_cloudy[mask_clouds] = ring[mask_clouds]

        # hist_2: Histogram of label values of the cloudy part of the rings
        hist_ring_cloudy, hist_ring_cloudy_edges = histogram(ring_cloudy, bins=arange(ring.max()+2)-0.5)

        # percentage of cloudy part of the rings / total rings : Division of Hist 1 / Hist 2
        CloudRingPixelsPercentage = float32(hist_ring_cloudy) / float32(hist_ring) * 100.0

        # identify labeled blob for which the boundary layer (ring) is composed by more than thre_ring_cloudy percent.
        # exclude index = 0 with ([1:]) corresponding to the non-labelled blob (background).
        labels_clouds = array(where(CloudRingPixelsPercentage[1:] > thre_ring_cloudy)[0]) + 1

        label_mask_ravel = ravel(label_mask.copy())
        label_mask_ravel[in1d(label_mask_ravel, labels_clouds)] = 0
        label_mask = label_mask_ravel.reshape(label_mask.shape)
        return label_mask

    def L2A_UrbanBarePixelRecoveryCCI(self):
        if (self.tables.hasBand(self.tables.LCM) is True):
            LCM = self.tables.getBand(self.tables.LCM)
            CM = self.classificationMask

            UrbanCCIDIL = binary_dilation((LCM == 190), structure=disk(9))

            # ESA CCI Urban pixel recovery step 1 for notClassified pixels
            CM[UrbanCCIDIL & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)] = self._bareSoils    # Urban class = 190

            # ESA CCI Urban pixel recovery step 2 for lowProbaClouds and medProbaClouds
            UrbanMask = (UrbanCCIDIL & ((CM == self._lowProbaClouds) | (CM == self._medProbaClouds)) & (CM!=self._noData) & (CM!=self._saturatedDefective)).astype('uint8')
            T_urban = 20 # 35.0
            Label_UrbanMask = self.L2A_FineMorphoRecovery(UrbanMask, CM, T_urban)
            subset = (Label_UrbanMask != 0) & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._bareSoils
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0

            # ESA CCI Bare pixel recovery step 1 for notClassified pixels
            subset = (LCM >= 200) & (LCM <= 202) & (CM == self._notClassified) & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._bareSoils    # Bare classes = 200, 201, 202
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0

            # ESA CCI Bare pixel recovery step 2 for lowProbaClouds and medProbaClouds
            BrightMask = ((LCM >= 200) & (LCM <= 202) & ((CM == self._lowProbaClouds) | (CM == self._medProbaClouds)) & (CM!=self._noData) & (CM!=self._saturatedDefective)).astype('uint8')
            T_bright = 35 # 35.0
            Label_BrightMask = self.L2A_FineMorphoRecovery(BrightMask, CM, T_bright)
            subset = (Label_BrightMask != 0) & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._bareSoils
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0
        return

    # def L2A_Bright_pixels_identification_Hollstein(self):
    #     B01 = self.tables.getBand(self.tables.B01)
    #     B03 = self.tables.getBand(self.tables.B03)
    #     B05 = self.tables.getBand(self.tables.B05)
    #     B10 = self.tables.getBand(self.tables.B10)
    #     B11 = self.tables.getBand(self.tables.B11)
    #     CM = self.classificationMask
    #     #F_bright = (B03 > 0.150) & ((B05/B11) < 4.330) & ((B11-B10) > 0.255) & (B01 < 0.30)
    #     F_bright = (B03 > 0.319) & ((B05/B11) < 4.330) & ((B11-B10) > 0.255) & (B01 < 0.30)
    #     All_proba_clouds = (CM == self._lowProbaClouds) | (CM == self._medProbaClouds) | (CM == self._highProbaClouds)
    #     #All_proba_clouds_opened = binary_dilation(binary_erosion(All_proba_clouds, structure=disk(3)), structure=disk(9))
    #     All_proba_clouds_opened = binary_dilation(binary_erosion(All_proba_clouds, structure=disk(2)), structure=disk(7))
    #     # (~All_proba_clouds_opened): protect small eroded clouds in the vicinity of large clouds
    #     subset = F_bright & All_proba_clouds & (~All_proba_clouds_opened) & (CM!=self._noData) & (CM!=self._saturatedDefective)
    #     CM[subset] = self._bareSoils # self._saturatedDefective #
    #     self.confidenceMaskCloud[subset] = 0.0
    #     self.confidenceMaskSnow[subset] = 0.0
    #     return


    # def L2A_Bright_pixels_identification_Fmask(self):
    #     B04 = self.tables.getBand(self.tables.B04)
    #     B8A = self.tables.getBand(self.tables.B8A)
    #     B11 = self.tables.getBand(self.tables.B11)
    #     CM = self.classificationMask
    #
    #     NDBI = (B11-B8A)/(B11+B8A)
    #     NDVI = (B8A-B04)/(B8A+B04)
    #
    #     F_bright = (NDBI > 0) & (NDBI > NDVI)
    #
    #     All_proba_clouds = (CM == self._lowProbaClouds) | (CM == self._medProbaClouds) | (CM == self._highProbaClouds)
    #
    #     # subset = F_bright & All_proba_clouds & (~All_proba_clouds_opened) & (CM!=self._noData) & (CM!=self._saturatedDefective)
    #     subset = F_bright & All_proba_clouds & (CM!=self._noData) & (CM!=self._saturatedDefective)
    #     CM[subset] = self._bareSoils
    #     self.confidenceMaskCloud[subset] = 0.0
    #     self.confidenceMaskSnow[subset] = 0.0
    #     return

    def L2A_EnhanceLine(self, mask):
        template = array([[-1, 2,-1],
                          [-1, 2,-1],
                          [-1, 2,-1]])/6.
        line_enhanced = ndimage.convolve(mask, template, mode='constant', cval=0.0)

        template = array([[-1,-1,-1],
                          [ 2, 2, 2],
                          [-1,-1,-1]])/6.
        line_enhanced_new = ndimage.convolve(mask, template, mode='constant', cval=0.0)
        line_enhanced = maximum(line_enhanced_new, line_enhanced)

        template = array([[ 2,-1,-1],
                          [-1, 2,-1],
                          [-1,-1, 2]])/6.
        line_enhanced_new = ndimage.convolve(mask, template, mode='constant', cval=0.0)
        line_enhanced = maximum(line_enhanced_new, line_enhanced)

        template = array([[-1,-1, 2],
                          [-1, 2,-1],
                          [ 2,-1,-1]])/6.
        line_enhanced_new = ndimage.convolve(mask, template, mode='constant', cval=0.0)
        return maximum(line_enhanced_new, line_enhanced)


    def L2A_Bright_pixels_Hollstein_Fmask(self):
        # Based on one of Hollstein branch:
        B01 = self.tables.getBand(self.tables.B01)
        B03 = self.tables.getBand(self.tables.B03)
        B05 = self.tables.getBand(self.tables.B05)
        B10 = self.tables.getBand(self.tables.B10)
        B11 = self.tables.getBand(self.tables.B11)
        CM = self.classificationMask

        Hollstein_bright = (B03 > 0.319) & ((B05/B11) < 4.330) & ((B11-B10) > 0.255) & (B01 < 0.30)

        del B01
        del B05
        del B10

        # Based on FMASK 4.0
        B04 = self.tables.getBand(self.tables.B04)
        B8A = self.tables.getBand(self.tables.B8A)

        NDBI = (B11-B8A)/(B11+B8A)
        NDVI = (B8A-B04)/(B8A+B04)

        del B04
        del B11

        NDBI = self.L2A_EnhanceLine(NDBI)
        FMASK_bright_enhanced = (NDBI > 0) & (NDBI > NDVI)

        water = ((B03-B8A)/(B8A+B03)) > 0.35
        if self.tables.hasBand(self.tables.WBI) is True:
            WBI = self.tables.getBand(self.tables.WBI)
            water = (WBI == 2)  # add WBI layer to help water identification

        del B03
        del B8A

        All_proba_clouds = (CM == self._lowProbaClouds) | (CM == self._medProbaClouds) | (CM == self._highProbaClouds)
        All_proba_clouds_opened = binary_dilation(binary_erosion(All_proba_clouds, structure=disk(3)), structure=disk(9))
        # (~All_proba_clouds_opened): protect small eroded clouds in the vicinity of large clouds

        conditions = (CM!=self._noData) & (CM!=self._saturatedDefective) & (~water) & (CM != self._thinCirrus)
        subset = (Hollstein_bright | FMASK_bright_enhanced) & All_proba_clouds & (~All_proba_clouds_opened) & conditions
        CM[subset] = self._bareSoils # self._saturatedDefective #
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0

        # special processing over water
        # if (self.tables.hasBand(self.tables.WBI) is True):
        #     WBI = self.tables.getBand(self.tables.WBI)
        #     CM[subset & (WBI == 2)] = self._water

        return

    def L2A_SHD(self):
        # Cloud shadow detection part2: Geometric input
        csd2 = self.L2A_CSHD_2_KLT_GAUSSIAN_BIS()
        # Cloud shadow detection part1: Radiometric input
        csd1 = self.L2A_CSHD_1(csd2)
        # Combination of Geometric and Radiometric information
        CSP = ((csd1 * csd2) > 0.05)
        self._arrayDistance = csd1
        del csd1
        del csd2

        CM = self.classificationMask

        CM[CSP] = self._cloudShadows
        return


    def L2A_CSHD_1(self, csd2):
        # Cloud shadow detection part1: Radiometric input
        #T_B02_B12 = self.config.T_B02_B12
        #T_water = 6.0
        T_water2 = 0.35

        x = self.config.nrows
        y = self.config.ncols
        BX = zeros((6, x, y), float32)
        BX[0, :, :] = self.tables.getBand(self.tables.B02)
        BX[1, :, :] = self.tables.getBand(self.tables.B03)
        BX[2, :, :] = self.tables.getBand(self.tables.B04)
        BX[3, :, :] = self.tables.getBand(self.tables.B8A)
        BX[4, :, :] = self.tables.getBand(self.tables.B11)
        BX[5, :, :] = self.tables.getBand(self.tables.B12)
        #RV_MEAN = array([0.0696000, 0.0526667, 0.0537708, 0.0752000, 0.0545000, 0.0255000], dtype=float32)
        RV_MEAN = array([0.12000, 0.08, 0.06, 0.10000, 0.0545000, 0.0255000], dtype=float32)
        # Modification JL 20160216
        distance = zeros((6, x, y), float32)
        for i in range(0, 6):
            distance[i, :, :] = (BX[i, :, :] - RV_MEAN[i])

        msd_dark = mean(distance < 0, axis=0)     # identify pixels with spectrum always under the reference shadow curve
        msd_dark = median_filter(msd_dark, 3)

        #water = (BX[0, :, :]/BX[4, :, :]) > T_water   # identify water pixels with B2/B11 > T_water
        water = ((BX[1, :, :] - BX[3, :, :]) / (BX[1, :, :] + BX[3, :, :])) > T_water2   # identify water pixels with (B3-B8A)/(B3+b8A) > T_water2 (0.35)
        del BX
        if self.tables.hasBand(self.tables.WBI) is True:
            WBI = self.tables.getBand(self.tables.WBI)
            water &= (WBI == 2)  # add WBI layer to help water identification

        msd = mean(abs(distance), axis=0).astype(float32)
        del distance

        msd = median_filter(msd, 3)
        msd = 1.0 - msd
        #T0 = 1.0 - T_B02_B12
        # test with T0 dependent of image radiometry of land pixels directly illuminated by the sun (no potential cloud shadow)
        CM = self.classificationMask

        land_no_snow = (CM == self._bareSoils) | (CM == self._vegetation)
        snow = (CM == self._snowIce)

        N_land_no_snow = land_no_snow.sum()
        N_snow = snow.sum()
        N_data = ((CM!=self._noData) & (CM!=self._saturatedDefective)).sum()

        # Use local statistics if clear land pixels (without snow) represent more than 2%
        # or if now pixels represents more than 5% of data
        if (N_land_no_snow > (0.02 * N_data)) | (N_snow > (0.05 * N_data)):

            # if snow pixels represents less than 10 times land pixels (veg + not_veg) -> shadow statistics on land pixels (without snow)
            if snow.sum() < (10 * land_no_snow.sum()):
                stats_region_land_no_snow = binary_erosion(land_no_snow & (csd2 < 0.01), ones((5, 5)))
                region_T0 = binary_dilation(~stats_region_land_no_snow, ones((25, 25))) & stats_region_land_no_snow
                mean_land_no_snow_msd = msd[region_T0].mean()
                std_land_no_snow_msd = msd[region_T0].std()
                #mean_land_no_snow_msd = msd[stats_region_land_no_snow].mean()
                #std_land_no_snow_msd = msd[stats_region_land_no_snow].std()
                del stats_region_land_no_snow
                del region_T0

                #T0 = clip(mean_land_no_snow_msd + 3 * std_land_no_snow_msd, 0.90, 0.9999)  #0.90 is for very bright area and 0.9999 for dark areas.
                T0 = clip(mean_land_no_snow_msd + 2 * std_land_no_snow_msd, 0.90, 0.9999)  #0.90 is for very bright area and 0.9999 for dark areas.
                msd[msd < T0] = 0.0
                self._maxShadowDistance = clip(mean_land_no_snow_msd + 2 * std_land_no_snow_msd, 0.88, 0.96)
            # else snow pixels represents more than 10 times land pixels (veg + not_veg) -> shadow statistics on snow (snowy / polar regions)
            else:
                stats_region_snow = binary_erosion(snow & (csd2 < 0.01), ones((5, 5)))
                region_T0 = binary_dilation(~stats_region_snow, ones((25, 25))) & stats_region_snow
                #mean_snow_msd = msd[stats_region_snow].mean()
                #std_snow_msd = msd[stats_region_snow].std()
                mean_snow_msd = msd[region_T0].mean()
                std_snow_msd = msd[region_T0].std()
                del stats_region_snow
                del region_T0

                T0 = clip(mean_snow_msd + 3 * std_snow_msd, 0.90, 0.9999)  #0.90 is for very bright area and 0.9999 for dark areas.
                msd[msd < T0] = 0.0
                self._maxShadowDistance = clip(mean_snow_msd + 2 * std_snow_msd, 0.88, 0.96)

        msd[msd_dark == 1.0] = 1.0    # add very dark pixel to potential cloud shadow

        # add current dark features pixels to potential cloud shadow if
        # local solar zenith angle < (local solar zenith angle + 5 deg)
        # and sza < 45
        if (self.tables.hasBand(self.tables.DEM) is True) & (self.config._solze_noclip < 45):
            cbeta = self.tables.getBand(self.tables.SDW)/255.
            T_lsza = 5.0 # corresponds to a variation of T_lsza deg of local solar zenith angle
            sza = self.config._solze_noclip
            sza_T_lsza = clip(sza + T_lsza, 0, 90)
            lsza_plus_5deg = cbeta > cos(sza_T_lsza * pi / 180.)
            msd[(CM == self._darkFeatures) & lsza_plus_5deg] = 1.0

        #msd[(CM == self._darkFeatures)] = 1.0    # disabled # add current dark features pixels to potential cloud shadow

        msd[water] = 0.0      # exclude water pixels identified above

        msd[CM == self._thinCirrus] = 0.0  # exclude cirrus pixels using classification mask
        msd[CM == self._medProbaClouds] = 0.0  # exclude _medProbaClouds pixels using classification mask
        msd[CM == self._highProbaClouds] = 0.0  # exclude _highProbaClouds pixels using classification mask

        return msd

    def L2A_CSHD_2_KLT_GAUSSIAN_BIS(self):
        # Cloud shadow detection part2: Geometric input
        # step 1: compute cloud height using parallax of bands B08 and B8A with KLT_Tracker
        # step 2: compute casted cloud shadow layer using casting shadow algorithm cythonized

        # workaround to read B08 (img_box) necessary for cloud height estimation
        # to be improved for official version:
        # img_box = self.tables.getBand(self.tables.B08)

        sourceDir = self.tables._L1C_bandDir
        dirs = sorted(os.listdir(sourceDir))
        filename = [jp2file for jp2file in dirs if 'B08.jp2' in jp2file][0]
        filename = os.path.join(sourceDir, filename)

        indataset = glymur.Jp2k(filename)

        if self.config.ROI == 'OFF':

            indataArr = indataset[:]

        else:  ##### start ROI processing

            if self.config.ROI == 'AUTO':
                scale = 6  # get rowTop, colLeft, rowBottom, colRight back in 10 m image reference system
            else:  # manual mode:
                scale = self.config.resolution / 10  # get rowTop, colLeft, rowBottom, colRight back in 10 m image reference system

            rowTop, colLeft, rowBottom, colRight = self.config.get_region_of_interest()
            rowTop *= scale
            rowBottom *= scale
            colLeft *= scale
            colRight *= scale

            nRowWin = rowBottom - rowTop
            nColWin = colRight - colLeft
            indataArr = zeros([nRowWin, nColWin], dtype=uint16)
            indataArr[0:nRowWin, 0:nColWin] = indataset[rowTop:rowBottom,colLeft:colRight]

        ##### end ROI processing

        if self.config.resolution == 20:
            img_box = uint16(block_reduce(indataArr, block_size=(2, 2), func=mean) + 0.5)
        else: # resolution is 60 m
            img_box = uint16(block_reduce(indataArr, block_size=(6, 6), func=mean) + 0.5)

        ref_box = (10000.0 * self.tables.getBand(self.tables.B8A)).astype(uint16)

        # KLT parallax processing for Bright Bare pixels and Snow pixels taking into account corrected B10 TOA reflect.
        # Keep here or elsewhere when reading of band B08 is standardized

        B10 = self.tables.getBand(self.tables.B10)
        CM = self.classificationMask
        cloud_mask = ((CM == self._medProbaClouds) | (CM == self._highProbaClouds) | (CM == self._thinCirrus)) & (CM != self._noData) & (CM != self._saturatedDefective)
        SnowMask = (CM == self._snowIce) & (CM != self._noData) & (CM != self._saturatedDefective)
        KLTMask = ((CM != self._noData) & (CM != self._saturatedDefective)).astype(uint8)

        # Perform KLT processing only if clouds (MP + HP + Cirrus) < 95% of pixels & KLTMask > 2% of MGRS tile
        #if ((cloud_mask.sum() / float(KLTMask.sum())) < 0.95) & ((KLTMask.sum() / float(CM.size)) > 0.02):
        #if (cloud_mask.sum() / KLTMask.sum()) < 0.95:

        # Perform KLT processing only if KLTMask > 2% of MGRS tile
        if (KLTMask.sum() / float(CM.size)) > 0.02:

            cloud_height = L2A_KLT_Tracker.compute_cloud_height_image(img_box, ref_box, KLTMask)

            if cloud_height.size > 0:

                # DEBUG save Cloud Height image file as TIF (does not work in PDGS mode)
                #            QI_DATA_output_dir = os.path.join(self._config._L2A_UP_DIR, 'GRANULE', self._config._L2A_TILE_ID, 'QI_DATA')
                #            cloud_height_file_TIF = os.path.join(QI_DATA_output_dir, 'CH.tif')
                #            from skimage import io
                #            io.imsave(cloud_height_file_TIF, cloud_height)
                # END DEBUG

                # Use cloud height derived from KLT to restore not-vegetated pixels and water pixels detected on ground
                # Only when cloud coverage is less than 0.95
                if (cloud_mask.sum() / float(KLTMask.sum())) < 0.95:

                    # B10 threshold computation
                    T_B10_Land = self._T_B10_Land # re-use B10 threshold computed in Cirrus recovery with B10

                    if (self.tables.hasBand(self.tables.DEM) is True):
                        dem = self.tables.getBand(self.tables.DEM)
                        cbeta = self.tables.getBand(self.tables.SDW).astype(float32) / 255.0
                        sza = self.config._solze_noclip
                        cos_sza = cos(sza * pi / 180.)
                        B10_correct = B10 * cos_sza / clip(cbeta, cos_sza, 1.0)  # correct for local incidence
                        B10_correct *= exp((-0.49 - 0.011 * dem / 1000.) * dem / 1000.)  # correct for water vapour distribution vs altitude
                    else:
                        B10_correct = B10

                    height_max = 350
                    conditions = (self.confidenceMaskCloud > 0) & (CM != self._thinCirrus) & (CM != self._noData) & (CM != self._saturatedDefective) & (CM != self._vegetation)
                    subset = (cloud_height < height_max) & (B10_correct < T_B10_Land) & conditions
                    cloud_mask[subset] = 0
                    self.confidenceMaskCloud[subset] = 0.0
                    CM[subset] = self._bareSoils

                    if (self.tables.hasBand(self.tables.WBI) is True):
                        WBI = self.tables.getBand(self.tables.WBI)
                        CM[subset & (WBI == 2)] = self._water

                    del subset

                # Use cloud height derived from KLT to restore clouds (identified as snow) in high altitude clouds
                height_min = 700 # was 1500
                conditions = (CM != self._noData) & (CM != self._saturatedDefective) & SnowMask
                subset_notsnow = (cloud_height > height_min) & conditions # & (B10_correct > T_B10_Land)
                cloud_mask[subset_notsnow] = 1
                CM[subset_notsnow] = self._medProbaClouds
                self.confidenceMaskSnow[subset_notsnow] = 0.0
                self.confidenceMaskCloud[subset_notsnow] = 0.5

                del subset_notsnow
                del SnowMask

        # end of KLT parallax processing

        # Cloud shadow detection part2: Geometric input -> casted cloud shadow probability

        cloud_mask = self.confidenceMaskCloud

        # Median Filter
        cloud_mask = median_filter(cloud_mask, (3, 3))  # modif JL20160216
        cloud_mask_dtype = cloud_mask.dtype

        # Dilatation cross-shape operator
        shape = generate_binary_structure(2, 1)
        cloud_mask = binary_dilation(cloud_mask > 0.33, shape).astype(uint8)

        result = L2A_KLT_Tracker.compute_cloud_height_stats(img_box, ref_box, cloud_mask)

        y = self.confidenceMaskCloud.shape[0]
        x = self.confidenceMaskCloud.shape[1]

        # fix for SIIMPC-1038, UMW: avoid floats as index, deprecated for numpy > 1.11f
        y_aa = int(y * 1.5 + 0.5)  # +50% to avoid FFT aliasing
        x_aa = int(x * 1.5 + 0.5)  # +50% to avoid FFT aliasing

        #cloud_mask = self.confidenceMaskCloud
        # filt_b = zeros([y_aa, x_aa], float32) #defined now further down
        cloud_mask_aa = zeros([y_aa, x_aa], float32)  # to avoid FFT aliasing

        # Read azimuth and elevation solar angles
        solar_azimuth = int(self.config.solaz + 0.5)  # modif JL20160208 original sun azimuth value
        solar_elevation = int(90.0 - self.config._solze_noclip + 0.5) # noclip version of solze needs to be used here to compute real casted shadows
        #solar_elevation = int(90.0 - self.config.solze + 0.5)

        # Median Filter
        #cloud_mask = median_filter(cloud_mask, (7, 7))
        #cloud_mask = median_filter(cloud_mask, (3, 3))  # modif JL20160216

        # Dilatation cross-shape operator
        #shape = generate_binary_structure(2, 1)
        #cloud_mask = binary_dilation(cloud_mask > 0.33, shape).astype(cloud_mask.dtype)

        # Create generic cloud height distribution for 30m pixel resolution and adapt it to 20m or 60m resolution (zoom)
        resolution = self.config.resolution

        if len(result) == 5:
            clouds_height_mean = result[0]
            clouds_height_std = result[1]
            clouds_height_min = result[2]
            clouds_height_max = result[3]
            clouds_height_number = result[4]

            if (clouds_height_mean + clouds_height_std) < 5000:
                heights = arange(clouds_height_mean + 4 * clouds_height_std)
                distr_clouds = stats.norm.pdf(heights, clouds_height_mean, clouds_height_std)/stats.norm.pdf(heights, clouds_height_mean, clouds_height_std).max()
                distr_clouds = zoom(distr_clouds, 1/float(resolution))
            else:
                def reverse(a): return a[::-1]
                distr_clouds = concatenate([reverse(1. / (1.0 + (arange(51) / 30.0) ** (2 * 5))), 1 / (1.0 + (arange(150) / 90.0) ** (2 * 5))])
                distr_clouds = zoom(distr_clouds, 30./float(resolution))

        else:
            def reverse(a): return a[::-1]
            distr_clouds = concatenate([reverse(1. / (1.0 + (arange(51) / 30.0) ** (2 * 5))), 1 / (1.0 + (arange(150) / 90.0) ** (2 * 5))])
            distr_clouds = zoom(distr_clouds, 30./float(resolution))

        # Create projected cloud shadow distribution
        #npts_shad = distr_clouds.size / tan(solar_elevation * pi / 180.)
        #factor = npts_shad/distr_clouds.size
        factor = 1 / tan(solar_elevation * pi / 180.)

        # SIITBX-46: to suppress unwanted user warning for zoom:
        import warnings
        warnings.filterwarnings('ignore')
        distr_shad = zoom(distr_clouds, factor)

        # Create filter for convolution (4 cases)
        filt_b = zeros([y_aa, x_aa], float32)

        if distr_shad.size > y_aa:
            filt_b[0:y_aa, 0] = distr_shad[0:y_aa]  # Corner case, maybe related to the fact that the solar zenith angle is > 85 deg
        else:
            filt_b[0:distr_shad.size, 0] = distr_shad  # Nominal case

        ys = float(y_aa/2.0)
        xs = float(x_aa/2.0)

        # Place into center for rotation:
        filt_b = roll(filt_b, int(ys), axis=0)
        filt_b = roll(filt_b, int(xs), axis=1)
        rot_angle = -solar_azimuth
        filt_b = rotate(filt_b, rot_angle, reshape=False, order=0)

        # case A:
        if (solar_azimuth >= 0) & (solar_azimuth < 90):
            filt_b = roll(filt_b, int(-ys), axis=0)
            filt_b = roll(filt_b, int(xs), axis=1)

        # case B:
        if (solar_azimuth >= 90) & (solar_azimuth < 180):
            filt_b = roll(filt_b, int(ys), axis=0)
            filt_b = roll(filt_b, int(xs), axis=1)

        # case C:
        if (solar_azimuth >= 180) & (solar_azimuth < 270):
            filt_b = roll(filt_b, int(ys), axis=0)
            filt_b = roll(filt_b, int(-xs), axis=1)

        # case D:
        if (solar_azimuth >= 270) & (solar_azimuth < 360):
            filt_b = roll(filt_b, int(-ys), axis=0)
            filt_b = roll(filt_b, int(-xs), axis=1)

        #Fill cloud_mask_aa with cloud_mask for the FFT computation
        if (y != self.confidenceMaskCloud.shape[0]) | (x != self.confidenceMaskCloud.shape[1]):
            tmp_cloud_mask = zeros([y, x], cloud_mask.dtype)
            if self.config.ROI == 'AUTO':
                scale = 60 / resolution
            else: # manual mode:
                scale = 1
            rowTop, colLeft, rowBottom, colRight = self.config.get_region_of_interest()
            rowTop *= scale
            rowBottom *= scale
            colLeft *= scale
            colRight *= scale
            tmp_cloud_mask[rowTop:rowBottom, colLeft:colRight] = cloud_mask[:, :]
            cloud_mask_aa[0:y, 0:x] = copy(tmp_cloud_mask[:, :]).astype(cloud_mask_dtype)
        else:
            cloud_mask_aa[0:y, 0:x] = copy(cloud_mask[:, :]).astype(cloud_mask_dtype)

        # Now perform the convolution:
        fft1 = fft.rfft2(cloud_mask_aa).astype(complex64)
        del cloud_mask_aa

        fft2 = fft.rfft2(filt_b).astype(complex64)
        del filt_b

        # proposal for new implementation
        fft1fft2 = fft1 * fft2
        del fft1
        del fft2
        shadow_prob_aa = fft.irfft2(fft1fft2).astype(float32)
        del fft1fft2

        shadow_prob = copy(shadow_prob_aa[0:y, 0:x])
        del shadow_prob_aa

        if (y != self.confidenceMaskCloud.shape[0]) | (x != self.confidenceMaskCloud.shape[1]):
            shadow_prob = copy(shadow_prob[rowTop:rowBottom, colLeft:colRight])

        # Normalisation:
        shadow_prob = clip(shadow_prob, 0.0, 1.0)

        # Remove cloud_mask from Shadow probability:
        shadow_prob = maximum((shadow_prob - cloud_mask), 0)
        del cloud_mask

        # Gaussian smoothing of Shadow probability
        value = 3
        shadow_prob = gaussian_filter(shadow_prob, value).astype(float32)

        # Remove data outside of interest:
        SC = self.classificationMask
        shadow_prob[(SC == self._noData) | (SC == self._saturatedDefective)] = 0.0
        return shadow_prob

        # # In case cloud shadows length should be limited:
        # if (self.tables.hasBand(self.tables.DEM) is True):
        #     dem = self.tables.getBand(self.tables.DEM)
        #     cloud_height = cloud_height + dem
        #
        # # Read azimuth and elevation solar angles
        # sza = float64(self.config._solze_noclip) # noclip version of solze needs to be used here to compute real casted shadows
        # saa = float64(mean(self.config.solaz_arr))
        #
        # # casting cloud shadow algorithm is performed at 20 m
        # resolution = 20.
        # x_res_size = 5490
        # y_res_size = 5490
        #
        # cols, rows = cloud_height.shape
        # if cols != x_res_size:
        #     cloud_height = (skit_resize(cloud_height.astype(int16), ([x_res_size, y_res_size]), order=3) * 32767.).round().astype(int16)
        # else:
        #     cloud_height = cloud_height.astype(int16)
        #
        # # casted shadow function here:
        # sdw = topographicshadows_cython_03.project_shadows(cloud_height.T, array([sza, saa]), float64(resolution), float64(resolution))
        #
        # return logical_not(sdw).astype(uint8)


    def L2A_WaterPixelRecoveryCCI(self):
        if self.tables.hasBand(self.tables.WBI) is True:
            WBI = self.tables.getBand(self.tables.WBI)
            CM = self.classificationMask
            subset = (WBI == 2) & ((CM == self._darkFeatures) | (CM == self._cloudShadows) | (CM == self._notClassified) | (CM == self._lowProbaClouds)) & (CM!=self._noData) & (CM!=self._saturatedDefective)
            CM[subset] = self._water
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0
        return

    def L2A_CloudShadowPixelCleaningwithDEM(self):
        # clean cloud shadow pixels detected in topographic shadow or steep slopes
        if self.tables.hasBand(self.tables.DEM) is True:
            shadow = self.tables.getBand(self.tables.SDW)
            T_Shadow = 1
            clean_area = (shadow == T_Shadow)  # modification with corrected casted shadow algorithm
            CM = self.classificationMask
            subset = clean_area & (CM == self._cloudShadows) & (CM != self._noData) & (CM != self._saturatedDefective)
            CM[subset] = self._darkFeatures
            self.confidenceMaskCloud[subset] = 0.0
            self.confidenceMaskSnow[subset] = 0.0
        return

    def L2A_TopograhicShadowCleaning(self):
        CM = self.classificationMask
        # assign bareSoils class (i.e. not-vegetated) to dark pixels not in topographic shadows: _darkNotShadow
        darkNotShadow = (CM == self._darkNotShadow)
        subset = darkNotShadow & (CM != self._noData) & (CM != self._saturatedDefective)
        CM[subset] = self._bareSoils
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0

        # Perform a soft dilation of casted (topographic) shadows to "close" the casted (topographic) shadows mask
        casted_shadow = (CM == self._darkFeatures)
        casted_shadow = binary_dilation(casted_shadow, disk(1))
        casted_shadow = median_filter(casted_shadow, 3)
        subset = casted_shadow & (CM != self._noData) & (CM != self._saturatedDefective)
        CM[subset] = self._darkFeatures
        self.confidenceMaskCloud[subset] = 0.0
        self.confidenceMaskSnow[subset] = 0.0
        return

    def process(self):
        self.config.timestamp('Pre process   ')
        if self.preprocess() == False:
            self.postprocess()
            self.config.timestamp('Post process  ')
            return True #False
        self.config.timestamp('L2A_SC init   ')
        self.L2A_CSND_1_1()
        self.config.timestamp('L2A_CSND_1_1  ')
        self.L2A_CSND_1_2()
        self.config.timestamp('L2A_CSND_1_2  ')
        if(self.tables.sceneCouldHaveSnow() is True):
            self.logger.info('Snow probability from climatology, detection will be performed')
            self.L2A_CSND_2_0()
            self.config.timestamp('L2A_CSND_2_0  ')
            self.L2A_CSND_2_1()
            self.config.timestamp('L2A_CSND_2_1  ')
            # JL 20180419  Updated because led to snow omission in low altitude region, e.g. Easton-MDE, 2018 March 22
            self.L2A_CSND_2_1bis()
            self.config.timestamp('L2A_CSND_2_1_2')
            # JL 20180419
            self.L2A_CSND_2_2()
            self.config.timestamp('L2A_CSND_2_2  ')
            self.L2A_CSND_2_3()
            self.config.timestamp('L2A_CSND_2_3  ')
            self.L2A_CSND_2_4()
            self.config.timestamp('L2A_CSND_2_4  ')
            self.L2A_CSND_2_5()
            self.config.timestamp('L2A_CSND_2_5  ')
            self.L2A_SnowPostProcessingCCI()
            self.config.timestamp('L2A_SnowPostProcessingCCI  ')
        else:
            self.logger.info('No snow probability from climatology, detection will be ignored')
        self.L2A_CSND_3()
        self.config.timestamp('L2A_CSND_3    ')
        #self.L2A_CSND_4()
        #self.config.timestamp('L2A_CSND_4    ')
        self.L2A_CSND_5_1()
        self.config.timestamp('L2A_CSND_5_1  ')
        self.L2A_CSND_5_2()
        self.config.timestamp('L2A_CSND_5_2  ')
        self.L2A_CSND_6()
        self.config.timestamp('L2A_CSND_6    ')
        self.L2A_CSND_6bis()
        self.config.timestamp('L2A_CSND_6_2  ')
        self.L2A_CSND_7()
        self.config.timestamp('L2A_CSND_7    ')
        self.L2A_DarkVegetationRecovery()
        self.config.timestamp('DV recovery   ')
        self.L2A_WaterPixelRecovery()
        self.config.timestamp('WP recovery   ')
        self.L2A_WaterPixelRecoveryCCI()
        self.config.timestamp('WP recovery with CCI Water Bodies at 150m  ')
        if (self.tables.hasBand(self.tables.DEM) is True):
            self.L2A_WaterPixelCleaningwithDEM()
            self.config.timestamp('Water Pixels cleaning with DEM')
            self.L2A_TopographicShadowwithDEM()
            self.config.timestamp('Topographic shadows classification over snow in mountainous area with DEM')
        self.L2A_SnowRecovery()
        self.config.timestamp('Snow recovery ')
        self.L2A_SnowSoilBorders()
        self.config.timestamp('SnowSoilBorders')
        self.L2A_SoilRecovery()
        self.config.timestamp('Soil recovery ')
        #self.L2A_LandPixelRecoveryB10B09B8A()
        #self.config.timestamp('Land recovery with B10, B09 and B8A ')
        self.L2A_CirrusPixelRecoveryB10()
        self.config.timestamp('Cirrus recovery with B10 ')
        self.L2A_UrbanBarePixelRecoveryCCI()
        self.config.timestamp('Urban and Bare pixel recovery with CCI Land Cover Map at 300 m ')
        # self.L2A_Bright_pixels_identification_Hollstein()
        # self.config.timestamp('Bright pixels identification Hollstein ')
        # self.L2A_Bright_pixels_identification_Fmask()
        # self.config.timestamp('Bright pixels identification Fmask')
        self.L2A_Bright_pixels_Hollstein_Fmask()
        self.config.timestamp('Bright pixels Hollstein Fmask')
        self.L2A_SHD()
        self.config.timestamp('L2A_SHD       ')
        self.L2A_WaterPixelRecoveryCCI()
        self.config.timestamp('WP recovery with CCI Water Bodies at 150m  ')
        if (self.tables.hasBand(self.tables.DEM) is True):
            self.L2A_CloudShadowPixelCleaningwithDEM()
            self.config.timestamp('Cloud Shadow Pixels cleaning with DEM')
        self.L2A_TopograhicShadowCleaning()
        self.config.timestamp('Topographic casted shadow Pixels post processing')

        dilate = True
        if dilate & (self.tables.hasBand(self.tables.LCM) is True) & (self.tables.hasBand(self.tables.WBI) is True):
            return self.postprocessnew
        else:
            return self.postprocess()
